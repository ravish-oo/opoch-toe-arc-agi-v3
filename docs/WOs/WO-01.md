Perfect—here’s a fully expanded, anchors-grounded **WO-01 — Π presentation (palette, D4 lex, anchor)** with harness steps and reviewer/implementer obligations. It plugs cleanly into the repo structure and WO-00 receipts kernel you just set up.

---

# WO-01 — Π presentation (palette, D4 lex, anchor)

## Objective

Implement **Π** and **U⁻¹** exactly as specified: inputs-only palette canon, D4 lexicographic pose selection, and anchor to (0,0). Π must be **idempotent** and **invertible** with receipts. No hidden heuristics.

* Math spec: §1 Presentation Π, §9 Un-present U⁻¹
* Engineering spec: §2 Presentation contract; receipts required
* Determinism addendum: frozen palette rules, D4 ids, anchor encoding, uint32_le hashing, no dynamic fields

---

## Files to add/change

```
arc/op/palette.py    # palette canon (inputs only), map/inv_map + receipts
arc/op/d4.py         # 8 poses, raster-lex comparator
arc/op/anchor.py     # bbox-to-(0,0)
arc/op/pi.py         # present() / unpresent()
scripts/run_wo.py    # add WO-01 branch
```

Keep WO-00 files as-is.

---

## Public contracts (frozen)

### `arc/op/palette.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass

@dataclass
class PaletteRc:
    palette_hash: str                     # BLAKE3 over (color,freq) table bytes
    palette_freqs: list[tuple[int,int]]   # [(color, freq), ...] sorted freq↓, value↑
    mapping: list[tuple[int,int]]         # [(orig -> code), ...] sorted by code

def build_palette_canon(inputs: list[np.ndarray]) -> tuple[dict[int,int], dict[int,int], PaletteRc]:
    """
    Build inputs-only palette map:
      1) Count color frequencies over ALL input grids (train inputs + test input).
      2) Sort by decreasing freq; tie by ascending color value.
      3) Assign codes 0..k-1 in that order.
    Returns (map, inv_map, receipts).
    """
```

### `arc/op/d4.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass

# D4 ids: 0=I, 1=R90, 2=R180, 3=R270, 4=FH, 5=FH∘R90, 6=FH∘R180, 7=FH∘R270
POSES = (0,1,2,3,4,5,6,7)

def apply_pose(G: np.ndarray, pose_id: int) -> np.ndarray: ...
def raster_lex_key(G: np.ndarray) -> tuple: ...
```

### `arc/op/anchor.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass

@dataclass
class AnchorRc:
    dr: int
    dc: int

def anchor_to_origin(G: np.ndarray) -> tuple[np.ndarray, AnchorRc]:
    """
    Translate so bbox of nonzero support touches (0,0).
    If grid is all zeros, dr=dc=0, return original.
    """
```

### `arc/op/pi.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass
from .palette import build_palette_canon, PaletteRc
from .d4 import apply_pose, raster_lex_key, POSES
from .anchor import anchor_to_origin, AnchorRc
from .hash import hash_grid

@dataclass
class PiRc:
    palette: PaletteRc
    pose_id: int
    anchor: AnchorRc
    roundtrip_hash: str

@dataclass
class PiTransform:
    # enough to invert: palette maps, pose, and anchor
    map: dict[int,int]
    inv_map: dict[int,int]
    pose_id: int
    anchor: AnchorRc

def present_all(train_inputs: list[np.ndarray], test_input: np.ndarray
               ) -> tuple[list[np.ndarray], np.ndarray, PiTransform, PiRc]:
    """
    Build inputs-only palette canon over (train_inputs + test_input).
    Choose a D4 pose (lex-min after anchoring) and anchor for *each grid*?
    Spec requires Π applied to *every input grid*; for receipts, record for the test grid.
    Return canonized train inputs, canonized test input, and a PiTransform sufficient to invert test later.
    """
def unpresent(T: PiTransform, Yt: np.ndarray) -> np.ndarray:
    """Inverse anchor, inverse D4, inverse palette map on the test."""
```

> Why pose receipts only for test? You’ll often record Π receipts per grid in the run receipts, but the transform you need to invert at the end is the test’s Π. For debugging, you can also attach per-train Π receipts; both are fine as long as they follow the same rules.

---

## Algorithms (exact, frozen)

### A) Palette canon (inputs only)

1. Flatten all **input** grids (all training inputs + the test input), count frequencies per color (exact ints).
2. Sort by decreasing frequency; ties by ascending color value.
3. Assign codes 0..k-1 in that order.
4. Map: `orig→code`, `inv_map: code→orig`.
5. Display outputs (later WOs) through the same map; unseen output colors → identity fallback (doc’d here but used in WO-11).

**Receipts**

* `palette_freqs: [(color,freq),...]`
* `mapping: [(orig→code),...]`
* `palette_hash`: BLAKE3 over a deterministic byte serialization of the freq table (e.g., varints in order).

### B) D4 lex pose (with anchor)

For a grid `G`, enumerate all 8 poses `pose_id ∈ POSES`. For each:

* `Gpose = apply_pose(G, pose_id)`
* `Ganch, rc = anchor_to_origin(Gpose)`
* Build `key = raster_lex_key(Ganch)`; choose the pose with minimal key (python tuple lex).
* **Freeze**: the lex key is just the row-major tuple of uint32 cells (don’t hash to compare; direct tuple comparison is stable and unambiguous).
* Record `pose_id` and the chosen anchor `rc` for receipts and to invert later.

> We compare **after anchoring** so “floating” content doesn’t bias lex selection—this matches the engineering spec’s `anchor(D4(G))`.

### C) Anchor

* If all cells are 0: `(dr,dc)=(0,0)`, return `G`.
* Else find minimal row/col indices where any nonzero appears; shift so that min row→0 and min col→0.
* Encode `(dr,dc)` as signed (ZigZag LEB128) in later receipts when serialized; for runtime dataclass keep ints.

### D) Idempotence & invertibility

* Π must satisfy Π²=Π.
* `unpresent` must satisfy `unpresent(T, present(test).grid) == original_test_grid` byte-for-byte.

---

## Implementer skeletons

`arc/op/palette.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass
from .hash import hash_bytes
from .bytes import varu  # for stable palette_hash payload

@dataclass
class PaletteRc:
    palette_hash: str
    palette_freqs: list[tuple[int,int]]
    mapping: list[tuple[int,int]]

def build_palette_canon(inputs: list[np.ndarray]):
    freqs: dict[int,int] = {}
    for G in inputs:
        vals, counts = np.unique(G.astype(np.int64, copy=False), return_counts=True)
        for v, c in zip(vals.tolist(), counts.tolist()):
            freqs[v] = freqs.get(v, 0) + c
    # sort freq↓, value↑
    items = sorted(freqs.items(), key=lambda kv: (-kv[1], kv[0]))
    mapping = {color: idx for idx, (color, _) in enumerate(items)}
    inv_map = {idx: color for idx, (color, _) in enumerate(items)}
    # palette_hash over deterministic varint stream
    payload = bytearray()
    for color, cnt in items:
        payload += varu(color) + varu(cnt)
    rc = PaletteRc(
        palette_hash=hash_bytes(bytes(payload)),
        palette_freqs=items,
        mapping=[(k, v) for k, v in mapping.items()]
    )
    return mapping, inv_map, rc
```

`arc/op/d4.py`

```python
from __future__ import annotations
import numpy as np

POSES = (0,1,2,3,4,5,6,7)

def apply_pose(G: np.ndarray, pose_id: int) -> np.ndarray:
    if pose_id == 0:   return G
    if pose_id == 1:   return np.rot90(G, k=3)         # 90 cw
    if pose_id == 2:   return np.rot90(G, k=2)
    if pose_id == 3:   return np.rot90(G, k=1)         # 270 cw
    if pose_id == 4:   return np.fliplr(G)             # flip H
    if pose_id == 5:   return np.rot90(np.fliplr(G), k=3)
    if pose_id == 6:   return np.rot90(np.fliplr(G), k=2)
    if pose_id == 7:   return np.rot90(np.fliplr(G), k=1)
    raise ValueError("invalid pose_id")

def raster_lex_key(G: np.ndarray) -> tuple:
    # direct tuple of ints, row-major, for total order
    return tuple(int(x) for x in G.reshape(-1))
```

`arc/op/anchor.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass

@dataclass
class AnchorRc:
    dr: int
    dc: int

def anchor_to_origin(G: np.ndarray) -> tuple[np.ndarray, AnchorRc]:
    nz = np.argwhere(G != 0)
    if nz.size == 0:
        return G, AnchorRc(0,0)
    rmin = int(nz[:,0].min())
    cmin = int(nz[:,1].min())
    if rmin == 0 and cmin == 0:
        return G, AnchorRc(0,0)
    H, W = G.shape
    out = np.zeros_like(G)
    out[0:H - rmin, 0:W - cmin] = G[rmin:H, cmin:W]
    return out, AnchorRc(rmin, cmin)
```

`arc/op/pi.py`

```python
from __future__ import annotations
import numpy as np
from dataclasses import dataclass
from .palette import build_palette_canon, PaletteRc
from .d4 import apply_pose, raster_lex_key, POSES
from .anchor import anchor_to_origin, AnchorRc
from .hash import hash_grid

@dataclass
class PiRc:
    palette: PaletteRc
    pose_id: int
    anchor: AnchorRc
    roundtrip_hash: str

@dataclass
class PiTransform:
    map: dict[int,int]
    inv_map: dict[int,int]
    pose_id: int
    anchor: AnchorRc

def _apply_palette(G: np.ndarray, mapping: dict[int,int]) -> np.ndarray:
    # map via vectorized approach
    uniq = np.unique(G)
    lut = {int(v): mapping[int(v)] for v in uniq}
    vfunc = np.vectorize(lambda x: lut[int(x)], otypes=[np.int64])
    return vfunc(G).astype(np.int64)

def _invert_palette(G: np.ndarray, inv_map: dict[int,int]) -> np.ndarray:
    uniq = np.unique(G)
    lut = {int(v): inv_map[int(v)] for v in uniq}
    vfunc = np.vectorize(lambda x: lut[int(x)], otypes=[np.int64])
    return vfunc(G).astype(np.int64)

def _choose_pose_and_anchor(G: np.ndarray) -> tuple[np.ndarray, int, AnchorRc]:
    best = None
    best_pose = 0
    best_anchor = AnchorRc(0,0)
    for pid in POSES:
        P = apply_pose(G, pid)
        A, rc = anchor_to_origin(P)
        key = raster_lex_key(A)
        if best is None or key < best:
            best = key
            best_pose = pid
            best_anchor = rc
            best_grid = A
    return best_grid, best_pose, best_anchor

def present_all(train_inputs: list[np.ndarray], test_input: np.ndarray):
    # 1) palette (inputs only)
    mapping, inv_map, pal_rc = build_palette_canon(train_inputs + [test_input])
    Xts = [_apply_palette(X, mapping) for X in train_inputs]
    Xt  = _apply_palette(test_input, mapping)
    # 2) D4 + anchor (for test; apply per-train similarly if desired)
    Xt_pose_anchor, pose_id, anchor = _choose_pose_and_anchor(Xt)
    # Π roundtrip for test grid: just check identity through unpresent
    T = PiTransform(mapping, inv_map, pose_id, anchor)
    roundtrip = unpresent(T, Xt_pose_anchor)
    rc = PiRc(
        palette=pal_rc,
        pose_id=pose_id,
        anchor=anchor,
        roundtrip_hash=hash_grid(roundtrip)
    )
    return Xts, Xt_pose_anchor, T, rc

def unpresent(T: PiTransform, Yt: np.ndarray) -> np.ndarray:
    # inverse anchor: shift back
    H, W = Yt.shape
    dr, dc = T.anchor.dr, T.anchor.dc
    invA = np.zeros((H + dr, W + dc), dtype=Yt.dtype)
    invA[dr:dr+H, dc:dc+W] = Yt
    # inverse D4: apply opposite transform
    inv_pose = {0:0, 1:3, 2:2, 3:1, 4:4, 5:7, 6:6, 7:5}[T.pose_id]
    invP = apply_pose(invA, inv_pose)
    # inverse palette
    return _invert_palette(invP, T.inv_map)
```

---

## Harness integration (scripts/run_wo.py)

Add a **WO-01** branch that:

* Loads each task id from `--subset` (only the test grid is needed here).
* Runs Π on **each input grid** and the test grid (required by spec).
* Writes receipts JSONL per task: `pi.palette_hash`, `pi.pose_id`, `pi.anchor`, `pi.roundtrip_hash`.
* Runs **twice** and asserts receipts identical (no timestamps, no randomness).

Pseudocode diff:

```python
if args.wo == "WO-01":
    # load ids
    # for each task: read train inputs + test input
    # Xts, Xt_tilde, T, pi_rc = present_all(...)
    # roundtrip_hash must equal hash_grid(original_test_input)
    # collect receipts per task into JSONL
    # run twice and compare exact equality
```

---

## Proof obligations (PO)

1. **Idempotence:** for every grid G, Π²(G)=Π(G).
2. **Invertibility (test):** U⁻¹(Π(test)) = original test grid (byte-for-byte).
3. **Inputs-only palette:** outputs never affect palette.
4. **D4 lex:** pose selection is stable and uses *anchored* lex key.
5. **Receipts present:** `palette_freqs/map/hash`, `pose_id`, `anchor(dr,dc)`, `roundtrip_hash`.

## Acceptance (on real ARC)

* Run `scripts/run_wo.py --wo WO-01 --data data/raw --subset data/ids.txt --receipts out/receipts/`
* **Oracle 3cd86f4f checks** (add these to reviewer prompt):

  * pose_id = 0, anchor = (0,0) on all grids for this task (observed earlier).
  * roundtrip_hash equals `hash_grid(original_test_input)` (compare programmatically).
* Double-run determinism: receipts JSONL are **exactly** identical.

## Red-team tests

* Add a fake output grid into palette canon input list → palette_hash changes; harness must catch via receipts diff.
* Rotate a grid whose anchored content is lex-equal to another pose → check we still pick the minimal `raster_lex_key` correctly.
* All-zero grid → anchor must be (0,0) and Π must not change data.

---

## Reviewer checklist (BLOCKER)

* [ ] `build_palette_canon` produces **inputs-only** mapping; `palette_freqs` sorted freq↓ then value↑; `palette_hash` present.
* [ ] `apply_pose`, `raster_lex_key`, and `anchor_to_origin` implemented; pose ids frozen to {0..7}.
* [ ] `present_all` applies palette, then chooses pose+anchor via anchored lex; `unpresent` inverts exactly.
* [ ] `roundtrip_hash == hash_grid(original_test_input)` for each task.
* [ ] Receipts JSONL has **no timestamps** or volatile fields; double-run equality holds.

---

## Notes tying back to anchors

* **No dynamic choices:** all steps are frozen; any drift is a bug.
* **Encodings:** hashes use uint32_le row-major (WO-00); offsets are signed ints but not yet serialized—serialization is enforced when receipts are persisted as bytes in later WOs (varints).
* **Idempotence & invertibility:** these are the algebraic invariants Π is required to satisfy and are now mechanically enforced.

---

If you want, I can paste a drop-in **`run_wo.py` WO-01 branch** next so you can copy it straight in.

# Patch from Common mistakes
Great—you parked the guide at `docs/common_mistakes.md`. For **WO-01**, the relevant mistakes are:

* **F1**: “Canonizing outputs or mixing test in palette semantics”
* **F2**: “Non-idempotent Π”

### Are they covered already?

* **F1** was **described** (inputs-only palette, receipts), but not fully **enforced** by code/receipts/harness.
* **F2** was **partly** enforced (test grid round-trip), but we didn’t require Π²=Π and U⁻¹∘Π=id for **every** grid.

Below is a small, surgical patch so both are enforced by construction.

---

## Patch (WO-01)

### 1) `arc/op/palette.py` — receipt says scope, and guard against outputs

Add a scope flag and an optional guard parameter to make intent explicit.

```diff
 @dataclass
 class PaletteRc:
     palette_hash: str
     palette_freqs: list[tuple[int,int]]
     mapping: list[tuple[int,int]]
+    scope: str  # "inputs_only"

-def build_palette_canon(inputs: list[np.ndarray]) -> tuple[dict[int,int], dict[int,int], PaletteRc]:
+def build_palette_canon(
+    inputs: list[np.ndarray],
+    *, forbid_outputs: bool = True
+) -> tuple[dict[int,int], dict[int,int], PaletteRc]:
     """
     Build inputs-only palette map:
       1) Count color frequencies over ALL input grids (train inputs + test input).
       2) Sort by decreasing freq; tie by ascending color value.
       3) Assign codes 0..k-1 in that order.
     Returns (map, inv_map, receipts).
     """
+    if forbid_outputs is not True:
+        raise ValueError("Palette canon must be built over inputs-only (forbid_outputs=True).")
```

At the end (when building the rc):

```diff
 rc = PaletteRc(
     palette_hash=hash_bytes(bytes(payload)),
     palette_freqs=items,
-    mapping=[(k, v) for k, v in mapping.items()]
+    mapping=[(k, v) for k, v in mapping.items()],
+    scope="inputs_only"
 )
```

### 2) `arc/op/pi.py` — apply Π to **every** grid, record per-grid Π² and round-trip

Make **every** grid (all train inputs + test) go through pose+anchor and prove idempotence and invertibility per grid. The test grid still provides the transform used later in the full operator, but we record receipts for **all** grids.

```diff
 @dataclass
 class PiRc:
-    palette: PaletteRc
-    pose_id: int
-    anchor: AnchorRc
-    roundtrip_hash: str
+    palette: PaletteRc
+    per_grid: list[dict]  # [{ "kind":"train"/"test", "pose_id":..., "anchor":{dr,dc}, "pi2_hash":..., "roundtrip_hash":... }, ...]
+    test_pose_id: int
+    test_anchor: AnchorRc

 @dataclass
 class PiTransform:
     map: dict[int,int]
     inv_map: dict[int,int]
-    pose_id: int
-    anchor: AnchorRc
+    pose_id: int        # for test
+    anchor: AnchorRc    # for test

-def present_all(train_inputs: list[np.ndarray], test_input: np.ndarray
-               ) -> tuple[list[np.ndarray], np.ndarray, PiTransform, PiRc]:
+def present_all(train_inputs: list[np.ndarray], test_input: np.ndarray
+               ) -> tuple[list[np.ndarray], np.ndarray, PiTransform, PiRc]:
     # 1) palette (inputs only)
-    mapping, inv_map, pal_rc = build_palette_canon(train_inputs + [test_input])
-    Xts = [_apply_palette(X, mapping) for X in train_inputs]
-    Xt  = _apply_palette(test_input, mapping)
-    # 2) D4 + anchor (for test; apply per-train similarly if desired)
-    Xt_pose_anchor, pose_id, anchor = _choose_pose_and_anchor(Xt)
-    # Π roundtrip for test grid: just check identity through unpresent
-    T = PiTransform(mapping, inv_map, pose_id, anchor)
-    roundtrip = unpresent(T, Xt_pose_anchor)
-    rc = PiRc(
-        palette=pal_rc,
-        pose_id=pose_id,
-        anchor=anchor,
-        roundtrip_hash=hash_grid(roundtrip)
-    )
-    return Xts, Xt_pose_anchor, T, rc
+    mapping, inv_map, pal_rc = build_palette_canon(train_inputs + [test_input], forbid_outputs=True)
+    # Apply palette
+    Xp_tr = [_apply_palette(X, mapping) for X in train_inputs]
+    Xp_te = _apply_palette(test_input, mapping)
+    # 2) D4 + anchor on EACH grid, prove Π²=Π and round-trip (per-grid receipts)
+    per_grid_rc = []
+    Xcanon_tr = []
+    for Xp in Xp_tr:
+        A1, pose1, anch1 = _choose_pose_and_anchor(Xp)
+        # Π²
+        A2, pose2, anch2 = _choose_pose_and_anchor(A1)
+        assert pose2 == pose1 and anch2 == anch1
+        pi2_hash = hash_grid(A2)
+        # round-trip for train grid uses its own transform
+        tr_T = PiTransform(mapping, inv_map, pose1, anch1)
+        rt = unpresent(tr_T, A1)
+        per_grid_rc.append({"kind":"train","pose_id":pose1,"anchor":{"dr":anch1.dr,"dc":anch1.dc},
+                            "pi2_hash":pi2_hash, "roundtrip_hash":hash_grid(rt)})
+        Xcanon_tr.append(A1)
+    # test grid
+    At, pose_t, anch_t = _choose_pose_and_anchor(Xp_te)
+    T = PiTransform(mapping, inv_map, pose_t, anch_t)
+    rt_test = unpresent(T, At)
+    per_grid_rc.append({"kind":"test","pose_id":pose_t,"anchor":{"dr":anch_t.dr,"dc":anch_t.dc},
+                        "pi2_hash":hash_grid(At), "roundtrip_hash":hash_grid(rt_test)})
+    rc = PiRc(
+        palette=pal_rc,
+        per_grid=per_grid_rc,
+        test_pose_id=pose_t,
+        test_anchor=anch_t
+    )
+    return Xcanon_tr, At, T, rc
```

### 3) `scripts/run_wo.py` — harness assertions for F1 + F2

Add a WO-01 branch that:

* Confirms `rc.palette.scope == "inputs_only"` (F1).
* Confirms **every** per-grid record has **Π² hash** and **round-trip hash** equal to the originals.

Illustrative snippet:

```python
if args.wo == "WO-01":
    # load ids list, iterate tasks
    # for each task, read train inputs + test input into numpy arrays GI
    Xcanon_tr, Xt_tilde, T, rc = present_all(train_inputs, test_input)
    assert rc.palette.scope == "inputs_only"
    # Recompute original hashes to compare round-trips
    import numpy as np
    from arc.op.hash import hash_grid
    # Check train grids
    for (orig, canon, per_rc) in zip(train_inputs, Xcanon_tr, [r for r in rc.per_grid if r["kind"]=="train"]):
        # Π²=Π: pi2_hash must equal hash_grid(canon)
        assert per_rc["pi2_hash"] == hash_grid(canon)
        # U⁻¹∘Π = id: roundtrip_hash must equal hash of original
        assert per_rc["roundtrip_hash"] == hash_grid(orig)
    # Check test grid
    test_rc = [r for r in rc.per_grid if r["kind"]=="test"][0]
    assert test_rc["roundtrip_hash"] == hash_grid(test_input)
```

(Keep the double-run equality from WO-00; receipts must be exactly identical with no timestamps.)

---

## Result

* **F1 (palette misuse)** is now impossible to “accidentally” do: receipts show `scope="inputs_only"`, and the harness fails if anything else happens.
* **F2 (non-idempotent Π)** is proven for **every** grid via Π²=Π and U⁻¹∘Π=id round-trip hashes.

