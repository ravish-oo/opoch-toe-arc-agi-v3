Here’s a **receipts-first, deterministic** expansion of **WO-08 — Tie-break L (MAJOR)** that plugs cleanly into your existing WO-04/WO-10/WO-11 flow and bakes in the C1 placement tie-chain plus the frozen L-tuple from the addendum. Nothing heuristic, nothing ad hoc; every number you use is logged and compared lexicographically under a frozen key order.

---

# WO-08 — Tie-break L (if needed) (MAJOR)

## When this runs

* **WO-04**: `IntersectionRc.status == "underdetermined"` and `admissible_count ≥ 2` (multiple (φ,σ) laws reproduce all trainings).
* **WO-10 engines**: a finite engine (e.g., ColumnDict / MacroTiling / PooledBlocks / MarkersGrid) returns **multiple exact fits** differing only by placement/ties—hand the candidate list to Tie-break L.
* **WO-11 runner** calls `arc.op.tiebreak.resolve(...)` and records receipts.

## Objective

Given an **admissible set** of mutually exact laws ( \mathcal{L} = {\ell_1,\dots,\ell_n} ) (each an encoded (φ,σ) or engine law), compute a **frozen lexicographic argmin** over a **fixed cost tuple**:

[
\textsf{L}(\ell) = \big(
\underbrace{\text{L1_disp_anchors}}*{1},;
\underbrace{\text{param_len_bytes}}*{2},;
\underbrace{\text{recolor_bits}}*{3},;
\underbrace{\text{object_breaks}}*{4},;
\underbrace{\text{tie_code}}*{5},;
\underbrace{\text{residue_key}}*{6},;
\underbrace{\text{placement_keys?}}_{7}
\big)
]

and return `chosen_idx` and a **full candidate table receipt** with all keys. This is the only place we pick among exact equals; it must be frozen and logged.

### Frozen components (from the addendum)

1. **L1_disp_anchors**: (\sum_{\text{pieces}} \lVert \Delta r, \Delta c \rVert_1) measured **on component/ coframe anchors** only (not all pixels).
2. **param_len_bytes**: length of the encoded φ (piecewise D4⊲ℤ² with residues) in **bytes**, using the frozen encoding (ZigZag LEB128 + framed).
3. **recolor_bits**: number of **moved colors** in σ’s domain (count of colors whose image ≠ identity).
4. **object_breaks**: (\max{0, #\text{components}(X\circ \phi) - #\text{components}(X)}) measured in the declared domain. **Merges do not penalize** (decreases are ignored).
5. **tie_code** (pose-class rank): **REF=0 < ROT=1 < TRANS=2**. Candidate’s tie_code is the **max** class across its pieces (frozen choice).
6. **residue_key**: prefer **smaller residues**: sort piece tuples ((r_per, r_res, c_per, c_res)) lex ascending and concatenate; compare lex as a whole.
7. **placement_keys (C1)** (only if the candidate set is flagged by the upstream engine/ witness as a **placement tie**):

   * **center_L1**: L1 distance of the candidate’s primary reference point(s) to the test grid center; if multiple placements, use lex of sorted distances.
   * **topmost_row**: minimal row index among placed anchors.
   * **leftmost_col**: minimal col index among placed anchors.
   * **skyline mode**: instead of center/top/left, use **first Π-appearance / max-rect anchor**, then **non-overlap left→right** ordering; encode as integers in the tuple (e.g., boolean flags + the first index).

> If an engine or witness does **not** declare a placement-tie, omit #7 entirely. The runner passes a `tie_context` that indicates which C1 chain applies (`"generic"` or `"skyline"`), else `None`.

---

## Deliverables

### `arc/op/tiebreak.py`

```python
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional, Literal, Dict, Any, Tuple
from blake3 import blake3

TieContextKind = Literal["generic_placement","skyline","none"]

@dataclass
class Candidate:
    # Canonical encodings required for receipts & cost:
    phi_bytes: bytes              # piecewise φ encoding (ZigZag LEB128 framed), or b"" if engine law
    sigma_domain_colors: List[int]
    sigma_lehmer: List[int]       # σ Lehmer code
    # Structural metrics precomputed by upstream or via helper hooks:
    anchor_displacements: List[Tuple[int,int]]           # [(dr,dc) per piece/coframe anchor]
    component_count_before: int
    component_count_after: int
    residue_list: List[Tuple[int,int,int,int]]           # [(r_per,r_res,c_per,c_res) per piece]
    pose_classes: List[Literal["REF","ROT","TRANS"]]     # per piece
    # Optional engine/placement keys:
    placement_refs: Optional[List[Tuple[int,int]]] = None  # anchor(s) or centroid(s) in Π-frame
    skyline_keys: Optional[Tuple[int,int,int]] = None      # (first_appearance_idx, no_overlap_flag, maxrect_rank)
    meta: Dict[str,Any] = None                             # any extra audit fields

@dataclass
class CandidateCost:
    idx: int
    l1_disp_anchors: int
    param_len_bytes: int
    recolor_bits: int
    object_breaks: int
    tie_code: int
    residue_key: Tuple[Tuple[int,int,int,int], ...]
    placement_keys: Optional[Tuple[int,int,int]]  # (center_L1, topmost_row, leftmost_col) or skyline variant
    cand_hash: str

@dataclass
class TieBreakRc:
    costs: List[CandidateCost]
    chosen_idx: int
    table_hash: str
    tie_context: TieContextKind

def resolve(cands: List[Candidate], *, tie_context: TieContextKind="none") -> Tuple[int, TieBreakRc]:
    """
    Compute frozen L-tuple for each candidate and return (chosen_idx, receipt).
    Deterministic: lex-min over (1..7) with 7 present only if tie_context != "none".
    """
```

### Cost computation (deterministic)

```python
POSE_RANK = {"REF":0, "ROT":1, "TRANS":2}

def _sum_l1(vs: List[Tuple[int,int]]) -> int:
    return sum(abs(dr)+abs(dc) for dr,dc in vs)

def _residue_key(residues: List[Tuple[int,int,int,int]]) -> Tuple[Tuple[int,int,int,int], ...]:
    return tuple(sorted(residues))  # lex

def _placement_keys_generic(placements: List[Tuple[int,int]], H:int, W:int) -> Tuple[int,int,int]:
    # center L1, then topmost, then leftmost (C1)
    cy, cx = (H-1)/2.0, (W-1)/2.0
    if not placements: 
        return (10**9, 10**9, 10**9)
    dists = sorted(int(abs(r-cy)+abs(c-cx)) for r,c in placements)
    center = dists[0]
    top = min(r for r,_ in placements)
    left = min(c for _,c in placements)
    return (center, top, left)

def _placement_keys_skyline(skyline_keys: Tuple[int,int,int]) -> Tuple[int,int,int]:
    # Already encoded as integers in frozen order: (first_pi_appearance, non_overlap_flag, maxrect_rank)
    return skyline_keys
```

`resolve` builds a `CandidateCost` for each candidate:

```python
def resolve(cands: List[Candidate], *, tie_context: TieContextKind="none"):
    costs: List[CandidateCost] = []
    # Assume caller supplies H,W via meta if placement keys needed
    H = cands[0].meta.get("H"); W = cands[0].meta.get("W") if cands and cands[0].meta else (None, None)

    for idx, c in enumerate(cands):
        l1 = _sum_l1(c.anchor_displacements)
        plen = len(c.phi_bytes)
        moved = sum(1 for i, tgt in enumerate(c.sigma_lehmer) if tgt != i)  # or domain-based
        ob = max(0, c.component_count_after - c.component_count_before)
        tc = max(POSE_RANK[p] for p in (c.pose_classes or ["REF"]))
        rk = _residue_key(c.residue_list or [])
        pk: Optional[Tuple[int,int,int]] = None
        if tie_context == "generic_placement":
            pk = _placement_keys_generic(c.placement_refs or [], H, W)
        elif tie_context == "skyline":
            if c.skyline_keys is None: pk = (10**9,10**9,10**9)
            else: pk = _placement_keys_skyline(c.skyline_keys)
        cost = CandidateCost(
            idx=idx,
            l1_disp_anchors=l1,
            param_len_bytes=plen,
            recolor_bits=moved,
            object_breaks=ob,
            tie_code=tc,
            residue_key=rk,
            placement_keys=pk,
            cand_hash=blake3((c.phi_bytes or b"") + bytes(c.sigma_lehmer)).hexdigest(),
        )
        costs.append(cost)

    # Lex order: include placement_keys only if context != "none"
    def key(cc: CandidateCost):
        base = (cc.l1_disp_anchors, cc.param_len_bytes, cc.recolor_bits, cc.object_breaks, cc.tie_code, cc.residue_key)
        return base + ((cc.placement_keys,) if tie_context != "none" else tuple())

    costs_sorted = sorted(costs, key=key)
    chosen_idx = costs_sorted[0].idx
    table_hash = blake3(("|".join(f"{c.idx}:{key(c)}" for c in costs_sorted)).encode()).hexdigest()
    rc = TieBreakRc(costs=costs_sorted, chosen_idx=chosen_idx, table_hash=table_hash, tie_context=tie_context)
    return chosen_idx, rc
```

> **Residue preference**: because `residue_key` is position 6, smaller residue periods/classes win before any placement keys. This follows the addendum.

---

## Receipts (first-class)

* **Candidate table**: full list of `CandidateCost` for every admissible law (indices stable).
* **chosen_idx**: the index of the selected candidate in the original order (not the sorted order).
* **table_hash**: BLAKE3 over the serialized cost lines (order+keys), so reviewers can assert stability even if enumeration order differs.
* **tie_context**: `"none" | "generic_placement" | "skyline"` ensures the C1 chain is only applied when appropriate and reproducibly.

---

## Harness (WO-08 branch in `scripts/run_wo.py`)

1. **Inputs**

   * For each task with `IntersectionRc.status == "underdetermined"` (from WO-04 or WO-10), collect the **admissible candidates** as `Candidate[]` with all fields populated, and a `tie_context`.
2. **Run**

```bash
python -m scripts.run_wo --wo WO-08 --data data/raw/ --subset data/ids.txt \
  --out out/ --receipts out/receipts/
```

3. **Assertions**

   * **Cost table** present for each task; all keys present.
   * **object_breaks** only counts increases (never negative).
   * **chosen_idx** equals **lex-min** of the frozen tuple; **reordering candidates in input must not change chosen_idx** (red-team: shuffle input order).
   * **Determinism**: run twice; `table_hash` unchanged.
4. **Red-team cases**

   * Two candidates with identical φ/σ except one uses a REF piece vs ROT: ensure tie_code makes REF win.
   * Two placements of the same motif at symmetric x-offsets: ensure **center_L1 then topmost then leftmost** picks the same side deterministically.
   * Two σ’s with equal moved_count but different Lehmer code: verify final “Lehmer-lex” behavior (we can add **Lehmer lex** as a last tiebreak if needed—receipt should include it).

---

## Integration points

* **WO-04**: when `IntersectionRc.status=="underdetermined"`, the runner constructs `Candidate[]` from the admissible (φ,σ) encodings and calls `tiebreak.resolve(...)`. Persist `TieBreakRc` under `witness.tie_break`.
* **WO-10**: finite engines that find multiple exact placements must **produce the same candidate structure** (with placement refs / skyline keys) and call `resolve()`.
* **WO-11**: the runner stores the final law as the selected candidate’s encoding and its `TieBreakRc` in the top-level receipts.

---

## C1 (unfrozen placement) — Compliance

* **No “left-pack” or ad-hoc selection**.
* The runner passes `tie_context` appropriately:

  * `"generic_placement"` for generic placement ties (bars/motifs).
  * `"skyline"` when the engine is a skyline-style placement (max-rect anchor then non-overlap left→right).
* Receipts include the **placement keys** in the cost tuple and the **candidate table**; reviewers can verify the “nearest center → topmost → leftmost” or “skyline chain” was applied.

---

## Reviewer checklist (MAJOR)

* [ ] All candidates are encoded and **costed**; `chosen_idx` equals lex-min of the **frozen** tuple.
* [ ] `object_breaks` counts only increases.
* [ ] `tie_code` mapped as REF(0) < ROT(1) < TRANS(2).
* [ ] `residue_key` respects “prefer smaller residues” before any placement keys.
* [ ] **C1** chain applied only when `tie_context` demands; placement keys present and consistent with Π/test frame.
* [ ] `table_hash` stable across re-runs; **shuffling input candidates does not change `chosen_idx`** (red-team).
* [ ] Receipts are complete; no hidden/implicit scoring.

---

## Notes / discussions

* We keep the **library total** and purely algebraic: no throws, no thresholds.
* The **denominator bound** for rational/floor S was frozen at 10 in WO-02; **Tie-break** has **no tunables**—all numbers come from encodings or geometry in Π/test frame.
* If you later add a new engine-specific tie key, **freeze name + order in addendum** and record it in `TieBreakRc`.

If you want, I can produce a small helper to convert WO-04 `phi`/`sigma` receipts into `Candidate` structs (including anchor displacements, component counts, residues, pose classes, and σ Lehmer) so the implementer can plug `resolve()` with minimal work.
