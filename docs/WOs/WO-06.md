Here’s a clean, receipts-first expansion of **WO-06 — Free copy S(p) (BLOCKER)** with the G2 guard baked in, plus a harness plan and code sketch. It plugs straight into your current repo and WO-04 receipts (uses the conjugated φ_i^* from `witness.conjugated[i].phi_star` and the Π-presented test grid `Xt`).

---

# WO-06 — Free copy S(p) (BLOCKER)

## Objective

Compute the **free-copy singleton set**
[
S(p);=;\bigcap_{i=1}^m {\phi_i^*(p)}
]
on the Π-presented test domain (\Omega_*). A pixel (p) is **free-copyable** iff **every** conjugated witness (\phi_i^*) is **defined at (p)** and **all images coincide** (set intersection is a singleton ({s})). This is *purely positional*; **no majority** and **no value voting**.

* If any (\phi_i^*) is **undefined** at (p) → (S(p)=\varnothing).
* If some (\phi_i^*) map (p) to **different** sources (s) → (S(p)=\varnothing).
* If any (\phi_i^*) has **multiple hits** for (p) (shouldn’t happen with disjoint pieces) → treat as **ambiguous** → (S(p)=\varnothing).

This implements **G2 (Majority copy is illegal)**.

The result is exposed as:

* a **bitset mask** (M\in{0,1}^{H\times W}) (row-major, **LSB-first per byte**) marking pixels with (|S(p)|=1);
* optionally a **copy-value map** (V\in\mathbb N^{H\times W}) with (V[p]=X_*(S(p))) for singleton pixels, and 0 elsewhere (used by WO-09 “copy” candidate).

Receipts are **first-class**: the mask is hashed, counts are explicit, and diagnostic tallies prevent silent drift.

---

## Deliverables

### `arc/op/copy.py`

```python
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Optional, Tuple
import numpy as np
from blake3 import blake3

@dataclass
class CopyRc:
    singleton_count: int                # number of p with |S(p)| == 1
    singleton_mask_hash: str            # BLAKE3 over bitset bytes (row-major, LSB-first)
    undefined_count: int                # #p where some φ_i* undefined
    disagree_count: int                 # #p where defined for all i but images differ
    multi_hit_count: int                # #p where some φ_i* gives >1 image (should be 0)
    # optional audit:
    H: int
    W: int

def build_free_copy_mask(
    test_grid: np.ndarray,                           # Π-presented X_*
    phi_stars: List[Optional[List[PhiPiece]]],       # conjugated per-train φ_i*, or None if summary
) -> Tuple[np.ndarray, Optional[np.ndarray], CopyRc]:
    """
    Compute S(p) = ⋂_i {φ_i*(p)}.
    Returns (mask_bitset_bytes, copy_values or None, CopyRc).
    """
```

**Notes**

* `PhiPiece` is the WO-04 encoding (pose_id, dr/dc, residue basis) in the **test** Π frame. Implement a tiny adapter to evaluate φ_i^*(p) → either ∅ or {s} (never >1 if pieces are disjoint; still guard).
* If a training produced **summary** witness (φ=None), its φ_i^* is **undefined everywhere**; the intersection becomes empty everywhere → mask of all zeros by design (aligns with spec).

### Receipts (first-class)

* `singleton_count`
* `singleton_mask_hash` = `blake3(bitset_bytes)` where `bit_index = r*W + c` and the **least significant bit** of byte `k` corresponds to index `8*k + 0`.
* Diagnostics: `undefined_count`, `disagree_count`, `multi_hit_count`, plus `H,W`.

This satisfies **G2** and makes silent errors impossible: if any implementer tries to “merge” sources or ignore undefineds, counts/mask hash will disagree across reviewers.

---

## Algorithm (deterministic, algebraic)

1. **Indexing**

   * Let (H,W = \text{test_grid.shape}). Precompute a flat index (idx(p)=r\cdot W + c).
   * Allocate `mask_bits = bytearray( (H*W + 7)//8 )` and (optional) `copy_values = np.zeros((H,W), dtype=int)`.

2. **Evaluate each φ_i^***

   * For each training (i):

     * If `phi_stars[i] is None` → mark all p as **undefined for i** (we’ll short-circuit to keep this cheap).
     * Else build a fast **piecewise evaluator**:

       * For each `PhiPiece` with `pose_id, dr, dc, r_per, c_per, r_res, c_res`, derive its **domain D_i,k ⊂ Ω_*** (the piece’s destination footprint) and the inverse mapping (\phi_i^{* -1}) on that domain: for (p\in D_{i,k}), the image is exactly one source coordinate (s).
       * Store a raster Boolean mask for each piece or a vectorized predicate to avoid per-pixel loops.

3. **Intersect images**

   * For each pixel (p):

     * Accumulate a small `found = []`.
     * For each i:

       * If (p \notin \text{dom}(\phi_i^*)) → `undefined_count += 1`; **continue** to next p (no singleton).
       * Else compute (s_i = \phi_i^*(p)). If **no/ambiguous** → `multi_hit_count += 1`; continue to next p.
       * Append (s_i) to `found`.
     * If `len(found) < m`: skip (intersection empty).
     * If not **all equal** (any (s_i \ne s_1)) → `disagree_count += 1`; skip.
     * Else set bit for p: `mask_bits[idx>>3] |= (1 << (idx & 7))`; `singleton_count += 1`.
     * Optionally assign `copy_values[r,c] = test_grid[s_1]` (Π-presented value) for WO-09.

4. **Finalize receipts**

   * `singleton_mask_hash = blake3(bytes(mask_bits)).hexdigest()`.
   * Return `(mask_bits, copy_values, CopyRc(...))`.

**Complexity:** (O(m\cdot HW)) with vectorized piece masks it’s fast on ≤30×30 grids.

---

## Harness (WO-06 branch in `scripts/run_wo.py`)

1. **Inputs**

   * For each `task_id` in `--subset`:

     * Load Π receipts for test: `Xt` from WO-01.
     * Load WO-04 **conjugated witnesses**: `witness.conjugated[i].phi_star` for all trainings i (if `kind=="summary"`, treat φ_i^*=None).
2. **Run**

   ```bash
   python -m scripts.run_wo --wo WO-06 --data data/raw/ --subset data/ids.txt \
     --out out/ --receipts out/receipts/
   ```

   * Call `build_free_copy_mask(Xt, phi_stars)`.
   * Write JSONL per task with `copy.singleton_count`, `singleton_mask_hash`, diagnostics, and optional `copy_value_hash = blake3(copy_values.tobytes())`.
3. **Determinism**

   * Run **twice**; receipts must be **identical** (no timestamps, no randoms).
   * Print summary line:

     ```
     WO-06: N tasks, total singletons=..., undefined=..., disagree=..., multi_hit=...
     ```
4. **Acceptance**

   * Choose a translation/mirror family where *every* training is geometric and φ_i^* agree (e.g., pure translate). Expect many singletons; check `singleton_count>0` and `copy_value_hash` constant across runs.
5. **Red-team**

   * Modify one training to be summary (φ=None): mask must be **all zeros**; `singleton_count=0`; `undefined_count ≈ H*W`.
   * Make one φ_i^* map `p` to a different source than others: `disagree_count` increments; mask bit **not** set; copy is **not** used at WO-09.

---

## G2 (Majority copy is illegal) — enforcement

* Implemented by definition of (S(p)=\bigcap_i{\phi_i^*(p)}).
* **No majority / no union**: if any i is undefined at p, or any image differs, **do not** set the bit.
* Receipts explicitly capture `undefined_count` / `disagree_count` / `multi_hit_count`, so any “merge” or heuristic sticks out immediately in review.

---

## Integration points

* **Input frame:** all positions are in **Π(test)** coordinates (you already ensured `phi_star` is conjugated to test in WO-04).
* **Meet (WO-09):** supply `mask_bits` + (optionally) `copy_values`. In WO-09, the `copy` candidate set is exactly `{ Xt[s] | S(p) = {s} }`; no other pixels are eligible for copy.
* **Truth (WO-05):** not required for WO-06. (Truth-assisted φ-retry, if you add WO-04.1 later, will just change the φ_i^* you receive here.)

---

## Reviewer checklist (BLOCKER)

* [ ] **G2 enforced**: any undefined or disagreement ⇒ no bit; counts (`undefined_count`, `disagree_count`, `multi_hit_count`) make sense.
* [ ] `singleton_count` equals popcount of the mask; `singleton_mask_hash` is **BLAKE3(row-major, LSB-first bitset)**.
* [ ] Determinism: two runs produce **identical receipts** (and optional `copy_value_hash`).
* [ ] On a pure translate/mirror task: non-zero `singleton_count`, expected coverage; on mixed (summary present): `singleton_count=0`.
* [ ] No heuristics, thresholds, or majority voting anywhere.

---

## Code sketch: bitset encoder (LSB-first)

```python
def mask_to_bitset(mask: np.ndarray) -> bytes:
    # mask: HxW uint8/bool, row-major
    H, W = mask.shape
    n = H * W
    out = bytearray((n + 7)//8)
    flat = mask.ravel(order="C").astype(np.uint8)
    for i, bit in enumerate(flat):
        if bit:
            out[i >> 5]  # warming cache is optional
            out[i >> 3] |= (1 << (i & 7))   # LSB-first
    return bytes(out)
```

---

### Why this satisfies the spec

* Pure positional **intersection** of singleton images per φ_i^*; no value voting → **G2** holds.
* **Receipts are first-class** (mask hash + diagnostics), enabling algebraic debugging.
* **Harness** is fail-closed by design and deterministic (double-run equality).
* It requires no extra assumptions and integrates cleanly with WO-04 and WO-09.
