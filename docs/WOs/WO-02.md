Here’s a fully expanded, receipts-first **WO-02 — Shape S synthesizer** that folds in your reminders, the harness, mistake E1 (shape without proof), the period-axis tie rule, and the optional COUNT-based qualifiers (with frozen encoding/qual-id hashing). This stays aligned with math + engg + addendum and plugs straight into the repo you froze.

---

# WO-02 — Shape **S** synthesizer (exact + least)

## Objective

Given presented grids’ shapes ((H,W)) and the known training output shapes ((R',C')), synthesize **S** as an exact mapping (S(H,W)=(R,C)) that:

1. **Fits all trainings** (proof by equality, not heuristics),
2. Picks the **least** candidate by the frozen ordering key,
3. Emits **first-class receipts** so reviewers can debug algebraically.

No guesses. No search trees. Only exact integer fits with receipts.

**Anchors:** Math §2 (Shape S), Engg §3, Addendum §1.1 (branch tags + serialization; ordering), §5 (unanimity pullback framing for later), period-axis tie rule, COUNT qualifier encoding.

---

## Files to add/change

```
arc/op/shape.py        # synthesizer + verifiers + receipts
scripts/run_wo.py      # add WO-02 branch in harness
```

---

## Public contracts (frozen)

### `arc/op/shape.py`

```python
from __future__ import annotations
from dataclasses import dataclass
from typing import Callable, Iterable

@dataclass
class ShapeRc:
    branch_byte: str                 # 'A','P','C','F'
    params_bytes_hex: str            # frozen serialization
    R: int
    C: int
    verified_train_ids: list[str]    # all trainings that matched, must include ALL
    extras: dict                     # axis_code for P; qual_id, qual_hash for C; etc.

# family API
SFn = Callable[[int,int], tuple[int,int]]

def synthesize_shape(
    train_pairs: list[tuple[str, tuple[int,int], tuple[int,int]]],  # [(id, (H,W), (R',C'))]
) -> tuple[SFn, ShapeRc]:
    """
    Return the chosen S(H,W)->(R,C) function and receipts.
    The candidate set is the frozen family list: AFFINE, PERIOD_MULTIPLE, COUNT, FRAME.
    The chosen candidate is min(branch_byte, params_bytes, R, C).
    All candidates MUST pass exact equalities for *every* training pair.
    """

def apply_shape(S: SFn, H: int, W: int) -> tuple[int,int]:
    """Pure application of the chosen law to test (H,W)."""
```

---

## Families and exact fitters (no heuristics)

We implement the four canonical families. Each fitter returns either **None** or a `(SFn, params_bytes, extras)` that **proves** every training pair.

### A) **AFFINE**: (R=aH+b,; C=cW+d)

* Solve `a,b` from distinct `H` values if available; else infer constants; same for `c,d` from `W`.
* **Verify** all trainings satisfy both equations exactly.
* **Serialize params**: `<4><a><b><c><d>` (varints; signed via ZigZag only if negative ever appears; we prefer non-negative per spec).
* **branch_byte** = `'A'`.

### B) **PERIOD_MULTIPLE**: LCM periods per axis

* Compute per-row minimal periods (p_r(i)) and per-col minimal periods (p_c(j)) (exact KMP).
* (p_r^{min} = \mathrm{lcm}{,p_r(i) > 1,} ;(\text{else } 1)), same for (p_c^{min}).
* Fit integers (k_r,k_c) such that ((R'_i,C'_i)=(k_r p_r^{min},, k_c p_c^{min})) **for all** trainings.
* **Axis tie rule (frozen)**: if both orientations yield admissible candidates with identical `(branch_byte, params_bytes)`, choose the axis with **more band runs**; if equal, **rows wins**. Record `axis_code` in receipts (`0` rows, `1` cols).
* **Serialize params**: `<2><k_r><k_c>` plus **record** `row_periods_lcm`, `col_periods_lcm` (bytes) in receipts `extras`.
* **branch_byte** = `'P'`.

### C) **COUNT-BASED** (optional; trivial until needed)

* Form: (R = \alpha_1\cdot q(X) + \beta_1,; C = \alpha_2\cdot q(X) + \beta_2) where (q) is a **qualifier**.
* Initial qualifier we allow now (simple, deterministic):

  * `q_rows(H,W) = H` (row count)  ← covers the 3cd86f4f “W+(H−1)” pattern via (\alpha_2=1,\beta_2 = (H-1)) which equals (\alpha_2\cdot q + \beta_2) with (\alpha_2=1,\beta_2=-1)? Practically we use (C=W+(q-1)) ⇒ encode as a specializer below.
  * `q_nonzero_rows` can come later if needed, but **disabled** by default.
* **Activation rule**: COUNT candidate is considered **only if** an equality **proof across all trainings** exists using a **registered qualifier**. Otherwise, do not emit C.
* **Serialize params**: `<4><alpha1><beta1><alpha2><beta2>` and **qualifier id** (ASCII) hashed; include `qual_id`, `qual_hash` in receipts `extras`.
* **branch_byte** = `'C'`.

> Practical note: For cases like (C=W+(H-1)), implement a tiny **adapter qualifier** `q_rows` with an **affine combiner** on (W) if and only if the equalities hold for all trainings. We still emit the C branch only when the proof is exact.

### D) **FRAME / BBox pad-to-multiple** (keep stubbed but exact)

* Only return a candidate if the trainings’ shapes prove a unique frame padding to a multiple (k) on either axis.
* **Serialize**: `<1><k>` per axis where applicable, include a descriptor in `extras`.
* **branch_byte** = `'F'`.

---

## Candidate selection (least)

After gathering **all passing** candidates:

```
key = (branch_byte, params_bytes, R_test, C_test)
```

Pick the **lexicographic minimum**. This is frozen (addendum). Record `branch_byte`, `params_bytes_hex`, `(R,C)`, `verified_train_ids`, and `extras`.

**Reminder (E1):** never emit a shape that isn’t proven on **every** training. If no family fits, fail-closed with a contradiction receipt (runner will route to later stages per spec, but the WO fails acceptance).

---

## Receipts (first-class; at all levels)

Emit **ShapeRc** with:

* `branch_byte` in `'A','P','C','F'`
* `params_bytes_hex` (deterministic serialization)
* `R, C` (for the test grid)
* `verified_train_ids` (must include **all**)
* `extras`:

  * For **P**: `axis_code`, `row_periods_lcm`, `col_periods_lcm`
  * For **C**: `qual_id`, `qual_hash` (BLAKE3 of the ASCII name), the integers (\alpha,\beta) per axis
  * For **F**: descriptor (e.g., `{"pad_to_multiple": {"rows": k_r, "cols": k_c}}`)

Additionally (module-level but per-candidate logging), during synthesis keep a local list:

```
candidates_log: [
  {"branch": "A", "params_hex": "...", "ok": true/false},
  {"branch": "P", "params_hex": "...", "axis_code": 0, "ok": true/false},
  {"branch": "C", "params_hex": "...", "qual_id": "q_rows", "ok": true/false},
  ...
]
```

You don’t have to persist the whole `candidates_log` in final runs, but during WO acceptance the reviewer may ask to print it—so keep a toggle in the harness to dump it.

---

## Implementer sketch

```python
# arc/op/shape.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Callable, Iterable
from blake3 import blake3
from .bytes import varu, frame_params

SFn = Callable[[int,int], tuple[int,int]]

@dataclass
class ShapeRc:
    branch_byte: str
    params_bytes_hex: str
    R: int
    C: int
    verified_train_ids: list[str]
    extras: dict

def _serialize_params_affine(a,b,c,d) -> bytes:
    return frame_params(4, a, b, c, d, signed=False)

def _serialize_params_period(kr,kc) -> bytes:
    return frame_params(2, kr, kc, signed=False)

def _serialize_params_count(a1,b1,a2,b2) -> bytes:
    return frame_params(4, a1, b1, a2, b2, signed=True)

def _hash_ascii(s: str) -> str:
    return blake3(s.encode()).hexdigest()

def _fit_affine(pairs):
    # Solve a,b from unique Hs; c,d from unique Ws; verify all
    Hs = [(hid, H, R) for hid,(H,W),(R,C) in pairs]
    Ws = [(hid, W, C) for hid,(H,W),(R,C) in pairs]
    # derive a,b if at least two distinct Hs; otherwise b=R - aH but under-determined ⇒ treat as constant a=0
    def solve_line(samples):
        vals = {}
        for _, x, y in samples:
            vals.setdefault(x, set()).add(y)
        xs = sorted(vals.keys())
        if len(xs) == 1:
            x = xs[0]; y = list(vals[x])[0]
            return 0, y  # y = 0*x + y
        x1,x2 = xs[:2]
        y1 = next(iter(vals[x1])); y2 = next(iter(vals[x2]))
        a = (y2 - y1) // (x2 - x1)
        b = y1 - a*x1
        # verify
        for _, x, y in samples:
            if a*x + b != y: return None
        return a,b
    ab = solve_line(Hs); cd = solve_line(Ws)
    if ab is None or cd is None: return None
    a,b = ab; c,d = cd
    def S(H,W): return (a*H + b, c*W + d)
    # full verification
    for _,(H,W),(R,C) in pairs:
        if S(H,W) != (R,C): return None
    return S, _serialize_params_affine(a,b,c,d), {}

def _lcm(a,b):
    import math
    if a==0 or b==0: return 0
    return abs(a*b)//math.gcd(a,b)

def _min_period_row(row):
    # exact minimal period via KMP
    n = len(row)
    lps = [0]*n
    j=0
    for i in range(1,n):
        while j>0 and row[i]!=row[j]: j=lps[j-1]
        if row[i]==row[j]: j+=1; lps[i]=j
    p = n - lps[-1]
    return p if p<n and n%p==0 else n

def _min_periods(G):
    import numpy as np
    H,W = G.shape
    pr = 1
    for i in range(H):
        p = _min_period_row(G[i].tolist())
        if p>1: pr = _lcm(pr,p)
    pc = 1
    for j in range(W):
        p = _min_period_row(G[:,j].tolist())
        if p>1: pc = _lcm(pc,p)
    return pr if pr>0 else 1, pc if pc>0 else 1

def _fit_period(pairs, presented_inputs):
    # presented_inputs: list of (hid, G_presented) to compute periods/LCM on train inputs
    # compute lcms from the *input* grids
    pr, pc = 1, 1
    for hid, G in presented_inputs:
        rmin,cmin = _min_periods(G)
        pr = _lcm(pr, rmin) if rmin>1 else pr
        pc = _lcm(pc, cmin) if cmin>1 else pc
    if pr==1 and pc==1:
        # degenerate: family gives multiples of 1; still test k_r,k_c
        pass
    # find kr,kc that satisfy all pairs
    # here outputs must be multiples of pr and pc respectively
    # kr = R'/pr (if pr>1 else arbitrary but must be equal across trainings)
    kr = None; kc = None
    for _,(_, _),(R,C) in pairs:
        if pr>1:
            if R%pr!=0: return None
            k = R//pr
            kr = k if kr is None else (kr if kr==k else None)
            if kr is None: return None
        else:
            kr = R  # treat pr=1 ⇒ kr=R, still deterministic for receipts
        if pc>1:
            if C%pc!=0: return None
            k = C//pc
            kc = k if kc is None else (kc if kc==k else None)
            if kc is None: return None
        else:
            kc = C
    def S(H,W): return (kr*max(1,pr), kc*max(1,pc))
    # verify
    for _,(H,W),(R,C) in pairs:
        if S(H,W)!=(R,C): return None
    params = _serialize_params_period(kr,kc)
    extras = {"row_periods_lcm": pr, "col_periods_lcm": pc, "axis_code": 0}  # axis_code filled by caller if tie logic used
    return S, params, extras

def _fit_count_rows(pairs):
    # Only allow R = a1*H + b1, C = a2*H + b2 (q_rows)
    # Solve a1,b1 from (H -> R); a2,b2 from (H -> C)
    H_R = [(hid,H,R) for hid,(H,W),(R,C) in pairs]
    H_C = [(hid,H,C) for hid,(H,W),(R,C) in pairs]
    def solve(samples):
        xs = sorted({x for _,x,_ in samples})
        # at least two distinct H required; else fall back to constant
        if len(xs)==1:
            x = xs[0]; y = next(y for _,xx,y in samples if xx==x)
            return 0, y
        x1,x2 = xs[:2]
        y1 = next(y for _,x,y in samples if x==x1)
        y2 = next(y for _,x,y in samples if x==x2)
        a = (y2-y1)//(x2-x1); b = y1 - a*x1
        for _,x,y in samples:
            if a*x + b != y: return None
        return a,b
    a1b1 = solve(H_R); a2b2 = solve(H_C)
    if a1b1 is None or a2b2 is None: return None
    a1,b1 = a1b1; a2,b2 = a2b2
    def S(H,W): return (a1*H + b1, a2*H + b2)
    for _,(H,W),(R,C) in pairs:
        if S(H,W)!=(R,C): return None
    params = _serialize_params_count(a1,b1,a2,b2)
    extras = {"qual_id":"q_rows","qual_hash": _hash_ascii("q_rows")}
    return S, params, extras

def synthesize_shape(train_pairs):
    """
    train_pairs: [(train_id, (H,W), (R',C'))]
    """
    candidates = []

    # AFFINE
    aff = _fit_affine(train_pairs)
    if aff: candidates.append(("A",) + aff)

    # PERIOD from presented inputs is preferred, but Π doesn’t change shape
    # so for WO-02 we can take inputs as-is; callers can pass presented grids later to refine
    # For now we cannot compute pr,pc without grids; leave a hook, or set (1,1).
    # If you have the actual train input grids, expose another API to pass them in and compute pr,pc.
    # Here we only include P if pr,pc are meaningful; otherwise skip.
    # (Implementer: in runner, call a version that receives presented inputs to fully enable P.)
    # candidates.append(("P",) + _fit_period(...))

    # COUNT (q_rows)
    cnt = _fit_count_rows(train_pairs)
    if cnt: candidates.append(("C",) + cnt)

    if not candidates:
        raise ValueError("SHAPE_CONTRADICTION: no family fits all trainings exactly")

    # pick least by (branch_byte, params_bytes, R_test, C_test) – R_test/C_test applied by caller
    # Here we don’t know test H,W; return the S with receipts, caller applies and rewrites R,C in ShapeRc
    # Choose by branch_byte + params_bytes only; the caller will complete with R,C for test.
    def key(c):  # c = (branch, SFn, params_bytes, extras)
        return (c[0], c[2])
    branch, S, params_bytes, extras = min(candidates, key=key)
    rc = ShapeRc(branch, params_bytes.hex(), -1, -1, [], extras)
    return S, rc

def apply_shape(S: SFn, H: int, W: int) -> tuple[int,int]:
    return S(H,W)
```

> Note on PERIOD: WO-02 API includes a hook to compute (p_r^{min}, p_c^{min}) from **presented inputs** (Π does not change ((H,W)), but periods rely on content). In the WO harness we’ll pass the actual grids (from data/raw) to enable PERIOD fully. If not passed, skip P rather than guess.

---

## Harness (scripts/run_wo.py)

Add a **WO-02** branch that:

1. Loads each task id and parses every **training pair** to collect ((H,W)) and ((R',C')).
2. Calls `synthesize_shape(train_pairs)` to get `(S,rc)`.
3. Applies `S` to the **test input** ((H,W)) to produce `(R,C)`; fills `rc.R, rc.C` and `rc.verified_train_ids` (all ids).
4. Asserts E1: **proof on all trainings** by re-checking equalities (even though the fitter already did).
5. Runs **twice** and asserts receipts identical.

Pseudo-snippet:

```python
if args.wo == "WO-02":
    # parse tasks into train_pairs = [(id,(H,W),(R',C'))]
    S, rc = synthesize_shape(train_pairs)
    # fill test R,C
    Ht, Wt = test_input.shape
    Rt, Ct = apply_shape(S, Ht, Wt)
    rc.R, rc.C = Rt, Ct
    rc.verified_train_ids = [tid for tid,_,_ in train_pairs]
    # re-verify equality proof (E1)
    for tid,(H,W),(R1,C1) in train_pairs:
        assert apply_shape(S,H,W) == (R1,C1)
    # receipts JSONL per task
    # double-run equality
```

---

## Acceptance (real ARC) & Red-team

**Acceptance on curated ids (`data/ids.txt`):**

* **3cd86f4f** should yield **`branch='C'`** with `qual_id='q_rows'`; test sizes: 4×4 → 4×? etc. (as in our oracle; confirm (C=W+(H-1)) form via C branch).
* **995c5fa3** and **23b5c85d** are good to sanity-check that AFFINE and/or FRAME/COUNT don’t spuriously pass unless exact.

**Red-team tests (harness toggles):**

* A task where both period axes look admissible: **receipts must include `axis_code` and follow the runs>rows rule** (when PERIOD candidate is enabled via passing grids).
* A task with single H across trainings (under-determined AFFINE): fitter must fall back to constant and still verify all pairs; or skip AFFINE; but **must not guess**.
* Remove one training pair: fitter should still work, but re-adding it must pass with the same result (determinism).

---

## Pre-flight (from common mistakes for this WO)

* **E1**: Never change output shape without an S proof. Receipt must show `{branch, params_bytes_hex, verified_train_ids}`; reviewer re-checks equalities.
* **Period-axis tie**: If both axes admissible, prefer **more runs**, else **rows**; record `axis_code`. No “looks better” choices.
* **COUNT qualifiers**: Only allow **registered** qualifiers; record `(qual_id, qual_hash)`; activate only with an equality proof on **all** trainings. No ad-hoc per-task formulas.

---

## Reviewer checklist (BLOCKER)

* [ ] `ShapeRc.branch_byte ∈ {'A','P','C','F'}`; `params_bytes_hex` present and stable.
* [ ] `rc.verified_train_ids` includes **all** trainings; reviewer recomputes and confirms (S(H_i,W_i)=(R'_i,C'_i)) for each.
* [ ] **PERIOD**: when used, `axis_code` present; `row_periods_lcm`, `col_periods_lcm` recorded.
* [ ] **COUNT**: when used, `qual_id` ∈ registered set (initially `q_rows`), `qual_hash` recorded; params `<4><α1><β1><α2><β2>` match the proof.
* [ ] Receipts identical across double run; no volatile fields.
* [ ] (Optional during WO): candidates log shows non-winners were evaluated and rejected by equality (helps debug).

---
