Fully expanded, receipts-first **WO-05 — Truth compiler (gfp) with frozen tags (BLOCKER)**. It’s wired to the anchors, locks the FFT/NTT rules, forbids dynamic tags, includes row/col cluster receipts, and ships with a harness flow so the reviewer can TDD it on `ids.txt`.

---

# WO-05 — Truth compiler (gfp) with frozen tags (BLOCKER)

## Objective

Compute the **coarsest bisimulation** (Paige–Tarjan fixed point) on a **frozen tag alphabet**, with integer-safe overlaps and exact verification. Output must be deterministic and receipts-rich so debugging is algebraic.

Anchors: frozen tag vocabulary, identity-overlap exclusion, integer-only transforms, receipts schema (addendum) ; math operator contract (truth = gfp on provable equalities) ; engineering spec (no heuristics, receipts) ; common-mistakes fundamentals & drift killers (D1, I1) .

---

## Files to add/change

```
arc/op/truth.py        # tag extractors + Paige–Tarjan + receipts
scripts/run_wo.py      # add WO-05 branch with determinism + acceptance checks
```

---

## Public contracts (frozen)

```python
# arc/op/truth.py
from __future__ import annotations
from dataclasses import dataclass
from typing import Dict, List, Tuple, Literal
import numpy as np

Method = Literal["fft_int","ntt"]

@dataclass
class OverlapRc:
    method: Method
    modulus: int | None
    root: int | None
    candidates: List[Tuple[int,int,int]]    # [(color, dr, dc), ...]
    accepted:  List[Tuple[int,int,int]]     # subset verified by pixel equality
    identity_excluded: bool                 # must be True

@dataclass
class TruthRc:
    tag_set_version: str
    refinement_steps: int
    block_hist: List[int]
    partition_hash: str
    # Optional deciding tables (only when used):
    row_clusters: List[int] | None          # sorted distinct row indices (bands)
    col_clusters: List[int] | None          # sorted distinct col indices (bands)
    overlap: OverlapRc | None               # per-color overlaps method+results

@dataclass
class TruthPartition:
    # map from (r,c) -> block id (int); you may store as 2D np.ndarray[int]
    blocks: np.ndarray

def compute_truth_partition(X: np.ndarray, *, method: Method="fft_int") -> tuple[TruthPartition, TruthRc]:
    """
    X is in Π frame. Build tags from the FROZEN vocabulary only, then run Paige–Tarjan
    to a fixed point. For overlaps use integer FFT/NTT; exclude identity Δ; accept
    only those candidates that pass exact pixel-equality verification.
    """
```

---

## Tag vocabulary (frozen, no dynamic tags)

**Local (radius = 1,2)**

* `color`
* `n4_adj`, `n8_adj`
* `samecomp_r2`
* `parity` (r%2, c%2)
* `row_period_2`, `row_period_3` (if whole window row is p-periodic)
* `col_period_2`, `col_period_3`

**Global**

* `per_line_min_period` (rows+cols) via **KMP**; record LCMs in receipts.
* `per_color_overlap` via **integer FFT** (fft_int) or **NTT**:

  * **Identity Δ must be excluded**.
  * Treat transform only as **candidate generator**; for each candidate Δ == (dr,dc), re-check by **exact pixel equality** on the implied overlap.
  * Receipts must record `(method, modulus/root when NTT, candidates, accepted)`.

**Row/Col clusters for band/sieve tasks (when used)**

* Freeze to **sorted distinct indices** of non-zero rows/cols or band delimiters (derived from tags), not distance-based clustering. Record `row_clusters`, `col_clusters`.

**Tag set version**

* Must equal the canonical string hash from the addendum; log `tag_set_version` in receipts. 

---

## Paige–Tarjan (coarsest bisimulation)

* Start with the partition by `color`.
* Iteratively refine with the frozen tags until no split occurs.
* Output `blocks: np.ndarray[int]` with a deterministic **partition_hash** (BLAKE3 over block IDs in raster order), `refinement_steps`, and `block_hist` (counts per block).

**Fail-closed**: if any required proof cannot be established (e.g., transform method not available), **do not** add ad-hoc tags; return a contradiction receipt for that proof path (but the algorithm still returns a partition from the remaining frozen tags). 

---

## Receipts (first-class, everywhere)

* `TruthRc`:

  * `tag_set_version` (exact canonical string)
  * `refinement_steps`, `block_hist`, `partition_hash`
  * `overlap` (if overlaps were attempted): `method`, `modulus/root` (for NTT), full `candidates` and `accepted`, and `identity_excluded=True`.
  * `row_clusters` / `col_clusters` when bands are used (e.g., 7bb29440, 2037f2c7).
* No runtime tag additions. No floats for logic (fft_int is integer FFT + equality verify). **Never derive from test outputs**. 

---

## Implementer sketch (core logic)

```python
# arc/op/truth.py (sketch)
from __future__ import annotations
import numpy as np
from dataclasses import dataclass
from blake3 import blake3
from typing import List, Tuple, Literal

Method = Literal["fft_int","ntt"]

CANON_TAG_VERSION = "color|n4_adj|n8_adj|samecomp_r2|parity|row_period_2|row_period_3|col_period_2|col_period_3|per_color_overlap|per_line_min_period|exact_tile|bbox_mirror|bbox_rotate"
TAG_VERSION_HASH = blake3(CANON_TAG_VERSION.encode()).hexdigest()  # freeze

@dataclass
class OverlapRc:
    method: Method
    modulus: int | None
    root: int | None
    candidates: List[Tuple[int,int,int]]
    accepted:  List[Tuple[int,int,int]]
    identity_excluded: bool

@dataclass
class TruthRc:
    tag_set_version: str
    refinement_steps: int
    block_hist: List[int]
    partition_hash: str
    row_clusters: List[int] | None
    col_clusters: List[int] | None
    overlap: OverlapRc | None

@dataclass
class TruthPartition:
    blocks: np.ndarray  # int32

def _kmp_min_period(arr: np.ndarray) -> int:
    n = len(arr); lps = [0]*n; j=0
    for i in range(1,n):
        while j>0 and arr[i]!=arr[j]: j=lps[j-1]
        if arr[i]==arr[j]: j+=1; lps[i]=j
    p = n - lps[-1]
    return p if p<n and n%p==0 else 1

def _per_line_min_periods(X: np.ndarray) -> tuple[int,int]:
    H,W = X.shape
    row_lcm = 1; col_lcm = 1
    import math
    for r in range(H):
        p = _kmp_min_period(X[r,:])
        if p>1: row_lcm = abs(row_lcm*p)//math.gcd(row_lcm,p)
    for c in range(W):
        p = _kmp_min_period(X[:,c])
        if p>1: col_lcm = abs(col_lcm*p)//math.gcd(col_lcm,p)
    return row_lcm if row_lcm>0 else 1, col_lcm if col_lcm>0 else 1

def _per_color_overlap_fft_int(X: np.ndarray, colors: List[int]) -> OverlapRc:
    # Integer-FFT candidate generator (details abstracted); always verify by exact equality;
    # exclude identity Δ.
    H,W = X.shape
    candidates = []
    accepted = []
    for c in colors:
        # (placeholder) enumerate a small, fixed Δ set around (0,0) except (0,0)
        for dr in range(-2,3):
            for dc in range(-2,3):
                if dr==0 and dc==0: continue
                # candidate generated; verify by pixel equality on overlap:
                r0 = max(0, dr);  r1 = min(H, H+dr)
                c0 = max(0, dc);  c1 = min(W, W+dc)
                if r1<=r0 or c1<=c0: continue
                A = (X[r0:r1, c0:c1] == c)
                B = (X[r0-dr:r1-dr, c0-dc:c1-dc] == c)
                if np.array_equal(A, B):
                    accepted.append((c, dr, dc))
                candidates.append((c, dr, dc))
    return OverlapRc(method="fft_int", modulus=None, root=None,
                     candidates=candidates, accepted=accepted, identity_excluded=True)

def _initial_partition_by_color(X: np.ndarray) -> np.ndarray:
    # Map unique colors to stable ranks 0..k-1 by ascending value
    vals = sorted(np.unique(X).tolist())
    rank = {v:i for i,v in enumerate(vals)}
    H,W = X.shape
    P = np.empty((H,W), dtype=np.int32)
    for r in range(H):
        for c in range(W):
            P[r,c] = rank[int(X[r,c])]
    return P

def _refine_once(X: np.ndarray, P: np.ndarray, tags: dict) -> np.ndarray:
    # Split blocks by tag signatures; this is a sketch — implement stable bucketing.
    # tags may include: n4/n8 adjacency vectors, samecomp_r2 flags, parity, small periods, etc.
    # The key property is determinism: signature serialization must be canonical.
    H,W = X.shape
    sig = {}
    keymap = {}
    nxt = 0
    out = np.empty_like(P)
    for r in range(H):
        for c in range(W):
            k = ( int(X[r,c]),                        # color
                  tags["n4"][r,c], tags["n8"][r,c],
                  tags["parity"][r%2][c%2],
                  tags["rowp2"][r], tags["rowp3"][r],
                  tags["colp2"][c], tags["colp3"][c],
                )
            if k not in keymap:
                keymap[k] = nxt; nxt += 1
            out[r,c] = keymap[k]
    return out

def compute_truth_partition(X: np.ndarray, *, method: Method="fft_int") -> tuple[TruthPartition, TruthRc]:
    H,W = X.shape
    # 1) Build frozen tags (no dynamic features)
    row_lcm, col_lcm = _per_line_min_periods(X)
    # (sketch) Build local tag planes: n4, n8, parity, row/col p∈{2,3} flags, samecomp_r2 (optional)
    tags = {
        "n4": np.zeros((H,W), dtype=np.uint8),  # fill
        "n8": np.zeros((H,W), dtype=np.uint8),
        "parity": ((0,1),(1,0)),                # schematic
        "rowp2": np.zeros(H, dtype=np.uint8),
        "rowp3": np.zeros(H, dtype=np.uint8),
        "colp2": np.zeros(W, dtype=np.uint8),
        "colp3": np.zeros(W, dtype=np.uint8),
    }
    # 2) Optional overlaps per color with verification; identity excluded
    colors = sorted(np.unique(X).tolist())
    if method == "fft_int":
        overlap_rc = _per_color_overlap_fft_int(X, colors)
    else:
        # NTT path would record (method="ntt", modulus, root) and verified accepted list
        raise NotImplementedError("NTT path to be added with fixed modulus/root")
    # 3) Paige–Tarjan fixed point
    P = _initial_partition_by_color(X)
    steps = 0
    while True:
        steps += 1
        P2 = _refine_once(X, P, tags)
        if np.array_equal(P2, P): break
        P = P2
    # 4) Receipts
    block_ids, counts = np.unique(P.reshape(-1), return_counts=True)
    block_hist = counts.tolist()
    part_hash = blake3(P.astype(np.int32).tobytes()).hexdigest()
    rc = TruthRc(
        tag_set_version=TAG_VERSION_HASH,
        refinement_steps=steps-1,
        block_hist=block_hist,
        partition_hash=part_hash,
        row_clusters=None, col_clusters=None,
        overlap=overlap_rc
    )
    return TruthPartition(blocks=P), rc
```

> The sketch illustrates the frozen mechanics and receipts. Your implementation must fill the local tag planes deterministically, and (optionally) compute row/col clusters when bands are in play (store `row_clusters`, `col_clusters`).

---

## Harness (`scripts/run_wo.py`) — what to run, what to assert

**WO-05 branch**:

1. For each `task_id` in `--subset data/ids.txt`:

   * Load **test input** (truth is computed on the test grid X* in Π frame).
   * Call `compute_truth_partition(Xt)` twice; verify **receipts identical** (determinism).
   * Write one JSONL record per task with `truth = TruthRc` (include `tag_set_version`, `partition_hash`, `overlap` fields).

2. **Acceptance checks** (on worked examples):

   * **Band/sieve ids** (e.g., `7bb29440`, `2037f2c7`): verify that `row_clusters` / `col_clusters` reflect the expected band boundaries and that `partition_hash` is stable and consistent with the known band grid. Identity Δ must be excluded in `overlap.identity_excluded`.
   * **Method receipts**: `overlap.method in {"fft_int","ntt"}`; if `"fft_int"` then `(verified=true)` is implicit via accepted list; if `"ntt"` you must record `(modulus, root)`.

3. **Fail-closed**: If overlaps cannot be verified (e.g., NTT missing), do not inject different tags; still compute the partition from the frozen tag set; receipts should show the proof path used (`method="fft_int"`). 

---

## Proof obligations (PO)

* **Frozen tag set only** — receipts `tag_set_version` equals the canonical hash. 
* **Fixed point reached** — nonzero `refinement_steps`, stable `partition_hash`.
* **Overlaps** — integer FFT/NTT only; **identity Δ excluded**; candidates listed; accepted Δ list verified by **pixel equality**; `(method, modulus/root or verified=true)` recorded. 
* **No test-output derivations** — all proofs from inputs or frozen tags; fail-closed if proof path missing. 

---

## Acceptance (real ARC)

* Run:

  ```bash
  python -m scripts.run_wo --wo WO-05 --data data/raw/ --subset data/ids.txt \
    --out out/ --receipts out/receipts/
  ```
* For **7bb29440** and **2037f2c7**: confirm `row_clusters` / `col_clusters` match the expected banding from `docs/worked_examples.md` and that `partition_hash` is stable; `overlap.identity_excluded==True`.
* Double-run determinism: receipts JSONL exactly equal (no timestamps, no random IDs).

---

## Red-team tests

* **Float drift (I1)**: force a code path that relies on float FFT without equality verification; reviewer must see **missing acceptance**; correct path uses **exact pixel equality** and lists accepted Δ. 
* **Dynamic tags (D1)**: add a “nearby row” threshold tag—reviewer must reject (`tag_set_version` mismatch; unknown tag). 
* **Identity Δ**: include (0,0) in candidates—reviewer must see `identity_excluded==True`; if not, reject per addendum. 

---

## Pre-flight (from common mistakes for this WO)

* **0) Fundamentals**: Never derive from test outputs; frozen tags only; fail-closed on missing proof; integer transforms; equality verification; identity Δ excluded. 
* **D1**: No dynamic/fuzzy clustering; when bands are used, record exact `row_clusters`, `col_clusters`. 
* **I1**: If FFT is used, it’s **candidate generation only**; accepted Δ must pass pixel equality; method & details recorded. 

---

## Reviewer checklist (BLOCKER)

* [ ] `tag_set_version` equals the canonical string hash (frozen). 
* [ ] `refinement_steps>0` (or appropriate), `partition_hash` present; double-run equality holds.
* [ ] `overlap.identity_excluded==True`; `candidates` and `accepted` lists recorded; `(method, modulus/root or verified=true)` recorded.
* [ ] If bands were used: `row_clusters` / `col_clusters` present and exact; no epsilon thresholds. 
* [ ] No extra tags; no floats for logic (unless verified); no derivations from outputs.

---

## Notes

* NTT path: when you enable it, use the fixed 64-bit friendly modulus and root as frozen in the addendum; record both in receipts. 
* The truth partition is **input-only** and independent of later write logic. Keeping receipts first-class here ensures any later disagreement (in Meet or Witness) localizes quickly to a tag or overlap proof.

