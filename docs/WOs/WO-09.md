Here’s a complete, receipts-first expansion of **WO-09 — Meet writer (copy ▷ law ▷ unanimity ▷ bottom)** with the H1/H2 guards baked in, precise interfaces to WO-06/07/04/10, and a harness so the reviewer can certify idempotence purely from receipts.

---

# WO-09 — Meet writer (copy ▷ law ▷ unanimity ▷ bottom) (BLOCKER)

## Objective

Compose the final Π-frame test output (\tilde Y_*) in **one pass** from three disjoint candidate layers and a fixed bottom color:

1. **copy** (from WO-06): per-pixel **singleton** free copies (S(p)={s}\Rightarrow \tilde X_*(s)).
2. **law** (from WO-04/WO-08 or WO-10 engine/WO-11 runner): per-pixel law color if defined at (p).
3. **unanimity** (from WO-07): truth-block constant (u(B)) if block (B\ni p) is unanimous (and copy+law didn’t fire).
4. **bottom = 0**: else paint **0** (frozen).

**Priority is frozen:** `copy ▷ law ▷ unanimity ▷ bottom`.
**Idempotence requirement (H1/H2):** run the same pass again over (\tilde Y_*) and hash; **repaint HASH must be identical**. Never re-enter the priority order, never use non-zero bottom.

---

## Inputs (Π-presented test frame)

* `Xt: np.ndarray[int]` — Π(test) grid, shape `(H*, W*)`.
* **Copy layer (WO-06):**

  * `copy_mask_bits: bytes` (row-major bitset, **LSB-first per byte**) for (p \mapsto |S(p)|=1).
  * `copy_values: Optional[np.ndarray[int]]` either:

    * provided by WO-06 as a full array with (V[p]=\tilde X_*(S(p))) for singleton p, else 0, **or**
    * `None` ⇒ we reconstruct on the fly as `Xt[src]` when S(p) is singleton (requires a `lookup_src(p)` from WO-06; if not provided, supply `copy_values`).
* **Law layer (from selected law):**

  * `law_mask_bits: Optional[bytes]` — bitset where law is defined at p.
  * `law_values: Optional[np.ndarray[int]]` — Π-frame color at p (same shape as Xt).
  * If the law is **full-frame** (engines that output entire (\tilde Y_*)), pass `law_mask_bits=None` and treat every pixel as defined.
  * If WO-04 ended **contradictory** and no engine was selected, pass both as `None` (law layer is empty).
* **Unanimity layer (WO-07):**

  * `truth_blocks: np.ndarray[int]` — block id per pixel in Π(test).
  * `block_color_map: Dict[int,int]` — only for blocks with unanimity; others absent. (G1 enforced in WO-07).

---

## Deliverables

### `arc/op/meet.py`

```python
from __future__ import annotations
from dataclasses import dataclass
from typing import Optional, Tuple, Dict
import numpy as np
from blake3 import blake3

@dataclass
class MeetRc:
    count_copy: int
    count_law: int
    count_unanimity: int
    count_bottom: int
    bottom_color: int                 # must be 0 (H2)
    repaint_hash: str                 # BLAKE3(Y_pass2)
    # Optional audit hashes for layers (helpful for algebraic diffs)
    copy_mask_hash: Optional[str]
    law_mask_hash: Optional[str]
    uni_mask_hash: Optional[str]
    # Frame & provenance (optional)
    frame: str                        # "presented"
    shape: Tuple[int,int]             # (H*, W*)
```

### API

```python
def compose_meet(
    Xt: np.ndarray,                             # Π(test), H* x W*
    copy_mask_bits: Optional[bytes],            # LSB-first bitset; None => no copy
    copy_values: Optional[np.ndarray],          # H* x W*, or None to derive from Xt via S(p)
    law_mask_bits: Optional[bytes],             # None => law defined everywhere (if law_values given), or nowhere (if law_values None)
    law_values: Optional[np.ndarray],           # H* x W*, or None
    truth_blocks: Optional[np.ndarray],         # H* x W*; required if block_color_map not empty
    block_color_map: Optional[Dict[int,int]],   # block_id -> color; None or {}
    *, bottom_color: int = 0                    # H2: must be 0
) -> Tuple[np.ndarray, MeetRc]:
    """
    One-pass write in fixed priority: copy ▷ law ▷ unanimity ▷ bottom.
    Returns final Y~ (H* x W*) and receipts.
    """
```

---

## Algorithm (single pass, idempotent)

1. **Decode bitsets** (if present) to `np.uint8` masks `Mcopy`, `Mlaw` (shape H×W).

   * Bit mapping: index = r*W + c; bit = `(bits[idx >> 3] >> (idx & 7)) & 1` (LSB-first).
   * `law_defined = Mlaw` if provided; else `law_defined = (law_values is not None) * ones(H,W)` when law is full; else zeros.

2. **Build a write plan** (no re-entry):

   * Initialize `Y = np.zeros_like(Xt, dtype=Xt.dtype)` (already bottom=0).
   * `written = np.zeros_like(Xt, dtype=np.bool_)` to track coverage (for counts only; not used to gate logic).
   * **COPY:** if `Mcopy[p]==1` → `Y[p] = copy_values[p]` (or `Xt[src]` if you reconstruct); `written[p]=True`; `count_copy++`.
   * **LAW:** where `~written & law_defined` → `Y[p] = law_values[p]`; `written[p]=True`; `count_law+=sum(...)`.
   * **UNANIMITY:** if `block_color_map` given: for each block id `b` with color `u`:

     * get boolean mask `Mb = (truth_blocks==b) & (~written)`; set `Y[Mb] = u`; `written[Mb]=True`; `count_unanimity+=Mb.sum()`.
   * **BOTTOM:** `count_bottom = (H*W - (count_copy+count_law+count_unanimity))`. Since `Y` was zero-filled and `bottom_color` is **0**, nothing else to write.

3. **Idempotence check (H1/H2):**

   * Re-run the exact same procedure on `Xt` and the same layers to produce `Y2`.
   * Compute `repaint_hash = blake3(Y2.tobytes()).hexdigest()`.
   * Assert (in harness) `Y2.tobytes() == Y.tobytes()`; else **fail** (latent re-entry or non-determinism).

4. **Receipts:**

   * `count_*`, `bottom_color=0`, `repaint_hash`.
   * Optional: `copy_mask_hash = blake3(copy_mask_bits).hexdigest()` (if provided), `law_mask_hash` (if provided), `uni_mask_hash = blake3( Mb_union_bits )`.
   * `frame="presented"`, `shape=(H,W)`.

---

## Receipts — first-class, algebraic

* Report exact **counts** `{copy, law, unanimity, bottom}`.
* **Idempotence proof**: `repaint_hash` matches the final output hash (the harness also compares Y vs Y2).
* When masks are provided, hash them to make “what got painted by which layer” immutable; reviewers can diff algebraically across runs.

---

## Integration contracts (upstream sources)

* **WO-06** → (copy_mask_bits, copy_values). If `copy_values` not supplied, WO-06 must provide a `source_of(p)` accessor or a `src_map` so `Xt[src]` can be read; simplest is to provide `copy_values`.
* **WO-04/WO-08** (witness) or **WO-10** (engine) → law layer:

  * If witness law is selected (singleton or tie-broken): provide `(law_mask_bits, law_values)`, where mask=1 exactly where law defines a color; values are π-frame colors.
  * If engine produces full output (e.g., Column-Dict): set `law_mask_bits=None`, `law_values=Ylaw` (full frame).
  * If contradictory / no law chosen: pass both `None` (law empty).
* **WO-07** → (truth_blocks, block_color_map) with G1 already enforced.

---

## Acceptance (on hand-solved IDs)

Run with the same `ids.txt` you used earlier:

```bash
python -m scripts.run_wo --wo WO-09 --data data/raw/ --subset data/ids.txt \
  --out out/ --receipts out/receipts/
```

**Expect:**

* `d5c634a2`, `995c5fa3`, `3cd86f4f`, `23b5c85d`, `2037f2c7`, `ccd554ac` — **Y matches oracle**;
* `{copy,law,unanimity,bottom}` reflect the family (e.g., for 23b5c85d, unanimity covers borders; for 3cd86f4f, law/summary supplies columns; copy=0 if no singleton S(p)).
* **Idempotence:** repaint hash equals final `blake3(Y)`; second pass no-op.

---

## Harness (WO-09 branch in `scripts/run_wo.py`)

1. **Load**:

   * Π(test) `Xt` (WO-01).
   * Copy layer receipts (WO-06).
   * Law layer: from runner selection (witness+tie or engine).
   * Unanimity layer (WO-07).
2. **Run** `compose_meet(...)` → `(Y, meet_rc)`.
3. **Repaint check**: run `compose_meet` **again** with identical inputs; assert `Y2.tobytes()==Y.tobytes()` and `blake3(Y2)==meet_rc.repaint_hash`.
4. **Write** `out/y_pred/<task>.json` and `meet` receipt with counts & hashes.
5. **Summary**:

```
WO-09: tasks=N, copy=X, law=Y, unanimity=Z, bottom=B, repaint_hash=<…>, bottom_color=0
```

6. **Red-team** (H1/H2):

   * Intentionally call `compose_meet` twice with a bug that re-enters priority (e.g., paint `unanimity` then `law` again): harness must detect repaint mismatch and **fail**.
   * Try `bottom_color=1`: receipt must show `bottom_color!=0`; harness rejects.

---

## Reviewer checklist (BLOCKER)

* [ ] **Priority is respected**: no pixel written by `law` or `unanimity` if `copy` already set; no re-entry.
* [ ] **Idempotence**: second pass leaves `Y` unchanged; `repaint_hash` equals `blake3(Y)`.
* [ ] **Bottom is 0**: `bottom_color==0`; no non-zero fill anywhere from bottom.
* [ ] **Counts** make sense (copy + law + unanimity + bottom = H×W).
* [ ] Optional mask hashes stable across runs; algebraic diffs possible.
* [ ] Determinism: receipts identical across double run.

---

## Notes / discussion

* **Why one pass?** It enforces the lattice-meet contract and prevents flicker. If an implementer re-orders or re-paints, the repaint hash check will fail.
* **Why bitsets?** They fix the per-pixel **provenance** of each layer without big JSON; reviewers can recompute and compare via BLAKE3.
* **Why bottom=0?** H2 freeze; ensures a unique minimal element in the meet poset and makes idempotence trivial.
