**WO-11 — Task runner + determinism harness (BLOCKER)** in a way that (a) wires every prior WO in the **exact frozen order**, (b) keeps **receipts first-class** and checks **J1 determinism**, and (c) handles **content-dependent**, **contradictory**, and **underdetermined** cases without breaking totality.

Below is the final implementer brief + reviewer/harness plan.

---

# WO-11 — Task runner + determinism harness (BLOCKER)

## Objective

Implement the **single commuting operator** end-to-end with receipts and determinism:

[
Y_* = U^{-1}!\big(\ \underbrace{\text{Meet}}*{09}\circ
\underbrace{\text{(copy 06 ⟂ law 04/10+08 ⟂ unanimity 07)}}*{\text{priority: copy≻law≻unanimity≻bottom}} \circ
\underbrace{\text{Truth gfp}}*{05} \circ
\underbrace{S\ \text{on}\ \Pi(X)}*{02\ \text{after}\ 01}\ \big)
]

**Order is frozen** (no reordering):
**Π(01)** → **S(02)** → **Truth(05)** → **Engines(10)→Witness(04)→Tie(08)** → **Copy(06)** → **Unanimity(07)** → **Meet(09)** → **U⁻¹(01)**.

**J1 Determinism:** run the whole pipeline **twice** per task, capture full receipts/hashes, and **fail** on any mismatch. Record `env_fingerprint`.

---

## Runner: `arc/runner.py`

```python
def solve_task(train_pairs: list[Tuple[str, np.ndarray, np.ndarray]],  # (train_id, X_i_raw, Y_i_raw)
               Xstar_raw: np.ndarray) -> Tuple[np.ndarray, Dict]:
    """
    Returns (Y_raw, receipts) for one task, running the frozen operator order once.
    Receipts are first-class and contain section receipts + their BLAKE3 hashes + a table_hash.
    """
```

### Step-by-step (frozen)

1. **Π — present inputs + test (WO-01).**

   * `Xt_list, Xstar_t, PiTrain[], PiStar, pi_rc = pi.present_all(train_X_raw, Xstar_raw)`.
   * **Receipt**: per-grid Π receipts (pose_id, anchor, palette scope, roundtrip_hash).
   * **Guard**: `pi_rc` must show `scope="inputs_only"`; `Π²=Π`, `U⁻¹∘Π=id`.
   * Record `hash_pi = blake3(serialize(pi_rc)).hexdigest()`.

2. **S — shape from WO-02, on presented sizes only.**

   * **Reuse** WO-02 **serialized params** (do **not re-fit**): `S = shape.deserialize(params_bytes, branch_byte)`.
   * Apply to **each training**: `(R_i, C_i) = S(H_i, W_i)`; check `Y_i.shape == (R_i,C_i)`; `verified_train_ids` must include all ids.
   * Apply to **test**: `(R*, C*) = S(H*, W*)`. Guard: `R*>0 && C*>0`.
   * **If WO-02 was `SHAPE_CONTRADICTION`:** **defer shape** to engines (WO-10) — move on to Truth and law selection; shape will be filled from engine receipts when available.
   * Record `shape_rc` and `hash_shape`.

3. **Truth — gfp on Π(test) (WO-05).**

   * `truth_part, truth_rc = truth.compute_truth_partition(Xstar_t)` (method per addendum; identity Δ excluded; candidates+accepted logged).
   * **Record** `row_clusters`, `col_clusters`, optional `row/col_nonzero_mask`.
   * Record `hash_truth`.
   * (Optional) **Truth-assisted signals** will be used downstream (engines and optional WO-04 retry).

4. **Law selection (hybrid): Engines → Witness → Tie**
   **Frozen decision tree:**

   * **If WO-02 gave `SHAPE_CONTRADICTION` or WO-04 ended `contradictory`/`summary`:** try **finite engines** (WO-10) **in frozen order**:
     `["border_scalar", "window_dict.column", "macro_tiling", "pooled_blocks", "markers_grid", "slice_stack", "kronecker"]`.

     * For each engine: `fit(train)`, verify exact reconstruction on all trainings. On success: `apply(test)` → `Ylaw_t`, `final_shape`.
     * **Receipts**: engine fit/apply receipts; lawful candidate sets (A1/A2), stage replication (B1/B2), placement/tie (C1), rule strings (C2).
     * If multiple engine placements fit exactly: build `Candidate[]`, call **WO-08** `tiebreak.resolve(..., tie_context)`; record `TieBreakRc`; select one.
     * **Law layer** becomes full-frame `law_values = Ylaw_t` (mask=None).
     * **If S was `SHAPE_CONTRADICTION`:** set **Shape.R/C** from `engine.apply.final_shape` with `shape_source="engine"`.
     * Stop engine loop on first success.
   * **Else** (or if engines all `ok=False`): run **Witness (WO-04)** using Π-train/test + Truth Rc (optional truth-assisted coframes if you implemented WO-04.1).

     * If **singleton**: build law layer: `law_mask_bits` + `law_values_t`.
     * If **underdetermined**: collect admissible candidates (φ,σ) → run **WO-08** (cost tuple positions 1–7) → select → build law layer.
     * If **contradictory**: **law layer empty**; Meet will rely on copy/unanimity/bottom; operator is still total.
   * Record `law_rc` and `tie_rc` (if any) and `hash_law`/`hash_tie`.

5. **Copy — free singletons (WO-06).**

   * Gather `phi_star` (conjugated) for all trainings from witness, or `None` for summary trainings.
   * `copy_bits, copy_vals, copy_rc = copy.build_free_copy_mask(Xt = Xstar_t, phi_stars = [...])`.
   * **G2 enforced**: intersection only; any undefined/disagreement/multi-hit ⇒ no bit.
   * Record `hash_copy_mask`, `copy_val_hash` (optional), `hash_copy_rc`.

6. **Unanimity — block constants (WO-07).**

   * `uni_rc = unanimity.compute_unanimity(truth_blocks, (H*,W*), [(tid,(H_i,W_i),(R_i,C_i),Y_i_raw], …))` using **frozen Π+S pullback**.
   * **G1 enforced**: per block we require non-empty `defined_train_ids` and all defined trainings equal; else **no** color.
   * Record `hash_unanimity`.

7. **Meet — one pass; bottom=0; idempotence (WO-09).**

   * `Yt, meet_rc = meet.compose_meet(Xt, copy_bits, copy_vals, law_mask_bits, law_values, truth_blocks, block_color_map, bottom_color=0)`
   * **Priority**: `copy ▷ law ▷ unanimity ▷ bottom(0)`; **single pass**; run a **second pass** and assert `repaint_hash` equals `blake3(Yt)`.
   * Record `hash_meet`, `final_shape = Yt.shape`.
   * **If law layer was empty and engines didn’t fit and witness was contradictory:** you still get a unique (Y_t) via copy/unanimity/bottom (totality), but mark `law_status="none|contradictory"` in receipts so it’s visible.

8. **U⁻¹ — unpresent to raw frame (WO-01).**

   * `Y_raw = pi.unpresent(PiStar, Yt)`; record `final output_hash = blake3(Y_raw)` and final `shape_raw = Y_raw.shape`.

9. **Aggregate receipts (first-class)**

   * Build `RunRc`:

     ```jsonc
     {
       "env": {platform, endian, py_version, blake3_version, compiler_version, build_flags_hash},
       "sections": {
           "pi": { ... }, "shape": {...}, "truth": {...}, "engines": {...}, "witness": {...},
           "tie": {...}, "copy": {...}, "unanimity": {...}, "meet": {...}
       },
       "hashes": {
           "pi": "...", "shape":"...", "truth":"...", "engines":"...", "witness":"...",
           "tie":"...", "copy":"...", "unanimity":"...", "meet":"...", "output":"..."
       },
       "table_hash": "blake3(concat(sorted(section_key + ':' + hash)))",
       "final": {"shape": [H_raw, W_raw], "law_status": "singleton|underdetermined|contradictory|engine|none"}
     }
     ```
   * **No timestamps**; all maps **key-sorted** before hashing; stable serialization.

---

## Batch Harness: `scripts/run_tasks.py`

```bash
python -m scripts.run_tasks --data data/raw/ --subset data/ids_test50.txt \
  --out out/ --receipts out/receipts/ --fail-fast
```

### Behavior

* Loads IDs (sorted), runs `solve_task` for each **twice**:

  * `r1 = solve_task(...); r2 = solve_task(...)`
  * Assert `r1.receipts == r2.receipts` and `blake3(r1.Y) == blake3(r2.Y)`; else **NONDETERMINISTIC_EXECUTION**.
* Asserts `env_fingerprint` stable across both runs; else **NONDETERMINISTIC_ENV**.
* Summarizes counts of `law_status` (singleton/underdetermined/contradictory/engine/none).
* **Default fail-fast**: if any task has unexpected status or any assertion fails, exit non-zero. Provide `--continue-on-error` to collect all receipts without early exit.

### Acceptance (curated ~30 tasks)

* The six hand-solved IDs (`d5c634a2`, `995c5fa3`, `3cd86f4f`, `23b5c85d`, `2037f2c7`, `ccd554ac`) must match oracle outputs; **repaint idempotence** passes.
* At least one Column-Dict case (e.g., `3f7978a0`) passes via engine with full receipts; if `UNSEEN_SIGNATURE`, fail-closed is accepted for now.
* A row-shift case that was “contradictory” at WO-04 remains contradictory unless truth-assisted φ-retry is implemented. That is **expected**; still produce total (Y) via meet & unanimity/bottom and show `law_status="contradictory"`.

### Red-team (J1)

* Flip any tie order (e.g., disable center/top/left chain) in a test branch: `hashes.tie` or `table_hash` must change; run must **fail** on determinism check.
* Change env (e.g., different `PYTHONHASHSEED`, endianness simulation): harness prints **NONDETERMINISTIC_ENV**.
* Insert a second pass in meet: `repaint_hash` changes; harness fails with “idempotence violated.”

---

## How the runner handles previously “parked” / non-singleton cases

* **108 content-dependent (parked at WO-02):** become testable **once WO-10 Column-Dict (or other engines) is present**. WO-11 tries engines first; if engine fits and applies, we set shape from engine and produce law layer = full frame; meet paints mostly by `law`. If none fit, we fall back to witness; if still contradictory, meet relies on copy/unanimity/bottom (total, but weaker).
* **202 contradictory (witness mixed types):** engines may resolve many by providing a canonical finite law; if engines fail and you later add **truth-assisted φ-retry** (optional WO-04.1), runner can pass `truth_rc` into witness retry before declaring `contradictory`.
* **89 underdetermined:** routed automatically to **WO-08** tie-break; if still structurally different, they remain underdetermined (law layer resolved only when tie’s candidates are admissible equals; else fallback to engines or remain underdetermined + meet). All of this is clear in receipts.

---

## J1 — Determinism & environment (frozen)

* **Freeze iteration orders** (IDs sorted; inner loops on colors / poses / residues sorted by the same lex order used in WOs).
* **No randomness**; if any library requires seeding, set `PYTHONHASHSEED=0`, `numpy.random.seed(0)` and log in `env_fingerprint`.
* Always log:

  * `env_fingerprint` (platform, endian, py_version, blake3_version, compiler_version, build_flags_hash).
  * Per-section hashes + `table_hash`.
* **Double-run the entire pipeline** per task; compare *full receipts* and *final output_hash*. On mismatch → exit with `NONDETERMINISTIC_EXECUTION`.

---

## Reviewer checklist (BLOCKER)

* [ ] **Order frozen**: Π→S→Truth→(Engines→Witness→Tie)→Copy→Unanimity→Meet→U⁻¹; receipts show each section and hash.
* [ ] **Receipts first-class**: section receipts present; section hashes + `table_hash` recorded.
* [ ] **Determinism**: two runs per task produce identical receipts and `output_hash`.
* [ ] **Env**: `env_fingerprint` present and compared; mismatches fail.
* [ ] **Law handling**: engines tried in frozen order; if engine chosen, witness is skipped; if witness underdetermined, WO-08 used; if contradictory and no engine, law layer empty and meet still produces total Y; status recorded.
* [ ] **Idempotence**: meet’s `repaint_hash` equals `blake3(Y)`; counts sum to H×W; `bottom_color==0`.
* [ ] **Frame consistency**: S applied on **presented** sizes; S reused from WO-02 (no refit); Truth on Π(test).
* [ ] **Fail-closed**: Any engine `UNSEEN_SIGNATURE`/conflict, or `SHAPE_CONTRADICTION`, is reported and triggers non-zero exit unless `--continue-on-error`.

---

## Final notes / missing items check

* We **did not** add any new non-frozen tunables (e.g., no variable `max_d` leaks; engines are frozen by schema; tie chains are frozen; bottom=0).
* **Under/contradictory** remain visible; they’re not errors. Engines and optional truth-assisted φ-retry will reduce them; otherwise, meet guarantees totality.
* **Shape** is **reused** and frame-consistent; if engines imply shape, we record `shape_source:"engine"` to keep the receipts honest.
* All **common-mistakes guards** (A1/A2/B1/B2/C1/C2/G1/G2/H1/H2/J1) are enforced by the wired WOs and their receipts/harness checks.
