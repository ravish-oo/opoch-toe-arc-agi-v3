A fully expanded, receipts-first **WO-03 — Components + stable matching (BLOCKER)**. It bakes in the “first-class receipts everywhere” rule, the harness, and the **D2 4-connected vs 8-connected** freeze.

---

# WO-03 — Components + stable matching (BLOCKER)

## Objective

Compute **deterministic 4-connected components per color**, derive a **canonical invariant tuple** for each, and perform a **stable one-to-one match** between components of two grids (X and Y) that is **pose/anchor/colour independent**. Provide receipts that let a reviewer debug algebraically.

Anchors: Math Π (§1) done; this WO prepares witness solving by giving a stable component basis. Addendum freezes: connectivity=4, invariant tuple, D4-min mask hashing, anchor_rc after Π, receipts.

---

## Files to add/change

```
arc/op/components.py      # NEW: CC4, invariants, stable matcher, pixelwise verify helper
scripts/run_wo.py         # Add WO-03 branch: run CC4 + match, emit receipts, determinism check
```

---

## Public contracts (frozen)

```python
# arc/op/components.py
from __future__ import annotations
from dataclasses import dataclass
import numpy as np
from typing import List, Tuple, Dict

@dataclass
class CompInv:
    color: int
    area: int
    bbox_h: int
    bbox_w: int
    perim4: int
    outline_hash: str     # D4-min mask hash (pose/color-independent)
    anchor_r: int         # top-left row of bbox in Π frame
    anchor_c: int         # top-left col of bbox in Π frame

@dataclass
class ComponentsRc:
    connectivity: str                 # "4" (frozen)
    per_color_counts: Dict[int,int]   # color → #components
    invariants: List[CompInv]         # lex order
    note: str | None = None

@dataclass
class MatchRc:
    pairs: List[Tuple[int,int]]       # indices into left/right invariants
    left_only: List[int]              # unmatched in left
    right_only: List[int]             # unmatched in right
    verified_pixelwise: bool          # all matched bbox equal after local alignment

def cc4_by_color(G: np.ndarray) -> Tuple[List[np.ndarray], ComponentsRc]:
    """Return list of component masks (one mask per component) sorted by invariant tuple,
       and receipts with per-color counts & invariants."""

def stable_match(left_masks: List[np.ndarray], right_masks: List[np.ndarray]) -> Tuple[List[Tuple[int,int]], MatchRc]:
    """Deterministic 1-1 pairing by lex order of invariant tuples (left→right)."""

def verify_pixelwise_equal(
    left_mask: np.ndarray, right_mask: np.ndarray, left_G: np.ndarray, right_G: np.ndarray
) -> bool:
    """Within each paired bbox, verify values equal (after aligning by bbox anchors)."""
```

> All coordinates are in the **Π frame** (WO-01), so anchor_rc is meaningful and stable.

---

## Algorithms (exact, frozen)

### 0) Connectivity (D2 freeze)

* **Always 4-adjacency per color.** Never 8-adjacency. Record `connectivity="4"` in receipts.

### 1) Extract components per color (Π frame)

* For each color `c` in the grid:

  * Build a boolean mask `M = (G == c)`.
  * Run 4-connected labeling on `M` (scanline or union-find). Skip empty color.
  * For each labeled blob, produce:

    * Bbox `(r0:r1, c0:c1)`, `anchor_rc=(r0,c0)`.
    * `area = #pixels`.
    * `perim4 =` 4-connected perimeter (count edges where neighbor is background).
    * `bbox_h = r1−r0`, `bbox_w = c1−c0`.
    * **outline_hash**: compute D4-minimal hash of the component’s *shape mask* cropped to bbox (ignore color).
      Steps:

      1. Extract the bbox mask `B` (dtype bool).
      2. Generate 8 D4 poses of `B`; for each pose, convert to bytes (uint8) row-major.
      3. Pick lexicographically minimal byte string; hash with BLAKE3 → `outline_hash`.

> D4-min removes pose dependence; using a mask removes color dependence.

* Append a **CompInv** with `(color, area, bbox_h, bbox_w, perim4, outline_hash, anchor_r, anchor_c)`.

### 2) Canonical invariant order (lex)

Sort all **CompInv** across all colors by the **lex key**:

```
(area, bbox_h, bbox_w, perim4, outline_hash, anchor_r, anchor_c, color)
```

This enforces a deterministic order even among identical shapes (tie broken by bbox anchor, then color as last key for pure duplicates).

### 3) Stable matching (left vs right)

Given two lists of components `L_invs` and `R_invs` (each with a side’s grids):

* Sort both lists by the same lex key (they are already sorted by cc4_by_color).
* Pair greedily **left-to-right** by equality of the lex key; if unequal, mark as unmatched (left_only/right_only).
* Output `pairs: [(iL, iR), …]` and the unmatched sets.

> This is a *matching on signatures*; it is deterministic and depends solely on invariants. It’s also maximal and stable.

### 4) Pixelwise verification (optional but required for receipts)

For each pair `(iL,iR)`:

* Align by bbox anchors; compare `G_left` and `G_right` within the overlap; assert values are equal for the component color (this is a preparatory check for witness solving). Record a boolean in the match receipt: `verified_pixelwise=True` only if all pass.

---

## Receipts (first-class at all levels)

* **ComponentsRc**

  * `connectivity="4"`
  * `per_color_counts`: `{color: count}`
  * `invariants`: full list of **CompInv** in sorted order (per component)
* **MatchRc**

  * `pairs`, `left_only`, `right_only`
  * `verified_pixelwise` = true/false
* These are **per-grid-pair** receipts. For WO-03 harness, we’ll typically run **X vs X** and **Y vs Y** sanity or **X vs Y** for tasks where shapes match; choose scenarios per acceptance below.

No volatile fields. No timestamps.

---

## Implementer sketch

```python
# arc/op/components.py
from __future__ import annotations
import numpy as np
from dataclasses import dataclass
from typing import List, Tuple, Dict
from blake3 import blake3

@dataclass
class CompInv:
    color: int; area: int; bbox_h: int; bbox_w: int; perim4: int
    outline_hash: str; anchor_r: int; anchor_c: int

@dataclass
class ComponentsRc:
    connectivity: str
    per_color_counts: Dict[int,int]
    invariants: List[CompInv]
    note: str | None = None

@dataclass
class MatchRc:
    pairs: List[Tuple[int,int]]
    left_only: List[int]
    right_only: List[int]
    verified_pixelwise: bool

def _d4_poses(B: np.ndarray) -> List[np.ndarray]:
    P = [B,
         np.rot90(B,3),
         np.rot90(B,2),
         np.rot90(B,1),
         np.fliplr(B),
         np.rot90(np.fliplr(B),3),
         np.rot90(np.fliplr(B),2),
         np.rot90(np.fliplr(B),1)]
    return P

def _outline_hash(B: np.ndarray) -> str:
    # B is boolean bbox mask
    cands = []
    for P in _d4_poses(B):
        b = P.astype(np.uint8).tobytes(order="C")
        cands.append(b)
    return blake3(min(cands)).hexdigest()

def _perimeter4(B: np.ndarray) -> int:
    H,W = B.shape
    per = 0
    # contributions where neighbor is background or out of bounds
    per += np.sum(B & np.pad(~B[:,1:], ((0,0),(0,1)), constant_values=True))  # right edge
    per += np.sum(B & np.pad(~B[1:,:], ((0,1),(0,0)), constant_values=True))  # down edge
    per += np.sum(B & np.pad(~B[:,:-1], ((0,0),(1,0)), constant_values=True)) # left edge
    per += np.sum(B & np.pad(~B[:-1,:], ((1,0),(0,0)), constant_values=True)) # up edge
    return int(per)

def _label_cc4(M: np.ndarray) -> np.ndarray:
    # Simple 4-connected labeling (two-pass)
    H,W = M.shape
    L = np.zeros((H,W), dtype=np.int32)
    parent = [0]
    def find(x):
        while parent[x] != x: parent[x] = parent[parent[x]]; x = parent[x]
        return x
    def union(a,b):
        ra, rb = find(a), find(b)
        if ra!=rb: parent[rb] = ra
    next_label = 1
    # first pass
    for r in range(H):
        for c in range(W):
            if not M[r,c]: continue
            nbs = []
            if r>0 and L[r-1,c]>0: nbs.append(L[r-1,c])
            if c>0 and L[r,c-1]>0: nbs.append(L[r,c-1])
            if not nbs:
                parent.append(len(parent))
                L[r,c] = next_label; parent[next_label] = next_label; next_label += 1
            else:
                lab = min(nbs); L[r,c] = lab
                for n in nbs: union(lab, n)
    # second pass
    label_map = {}
    new_id = 1
    for r in range(H):
        for c in range(W):
            if L[r,c]>0:
                root = find(L[r,c])
                if root not in label_map:
                    label_map[root] = new_id; new_id+=1
                L[r,c] = label_map[root]
    return L

def cc4_by_color(G: np.ndarray) -> Tuple[List[np.ndarray], ComponentsRc]:
    H,W = G.shape
    comps: List[np.ndarray] = []
    invs: List[CompInv] = []
    counts: Dict[int,int] = {}
    for color in sorted(np.unique(G).tolist()):
        if color is None: continue
        M = (G == color)
        if not M.any(): continue
        L = _label_cc4(M)
        num = int(L.max())
        counts[color] = num
        for lab in range(1, num+1):
            rr, cc = np.where(L == lab)
            r0, r1 = int(rr.min()), int(rr.max())+1
            c0, c1 = int(cc.min()), int(cc.max())+1
            B = (L[r0:r1, c0:c1] == lab)
            area = int(B.sum())
            per4 = _perimeter4(B)
            h, w = B.shape
            hsh = _outline_hash(B)
            invs.append(CompInv(color, area, h, w, per4, hsh, r0, c0))
            comps.append(B)  # NOTE: bbox-relative mask
    # stable lex sort
    order = sorted(range(len(invs)),
                   key=lambda i: (invs[i].area, invs[i].bbox_h, invs[i].bbox_w,
                                  invs[i].perim4, invs[i].outline_hash,
                                  invs[i].anchor_r, invs[i].anchor_c, invs[i].color))
    comps = [comps[i] for i in order]
    invs  = [invs[i]  for i in order]
    rc = ComponentsRc(connectivity="4", per_color_counts=counts, invariants=invs)
    return comps, rc

def stable_match(left_masks: List[np.ndarray], right_masks: List[np.ndarray]) -> Tuple[List[Tuple[int,int]], MatchRc]:
    # Match by invariant tuple equality; since callers retain sorted invariants, we just walk both in order
    i=j=0; pairs=[]; left_only=[]; right_only=[]
    while i < len(left_masks) and j < len(right_masks):
        # compare by shape bytes (they were sorted by invariants already)
        a = left_masks[i].astype(np.uint8).tobytes()
        b = right_masks[j].astype(np.uint8).tobytes()
        if a==b:
            pairs.append((i,j)); i+=1; j+=1
        elif a < b:
            left_only.append(i); i+=1
        else:
            right_only.append(j); j+=1
    while i < len(left_masks): left_only.append(i); i+=1
    while j < len(right_masks): right_only.append(j); j+=1
    return pairs, MatchRc(pairs, left_only, right_only, verified_pixelwise=False)

def verify_pixelwise_equal(left_mask: np.ndarray, right_mask: np.ndarray,
                           left_G: np.ndarray, right_G: np.ndarray) -> bool:
    # Align masks at (0,0) in their bbox frames; compare pixel values on masked cells
    if left_mask.shape != right_mask.shape: return False
    H,W = left_mask.shape
    # values equal on whole bbox for determinism check (color checks happen in witness)
    return bool(np.array_equal(left_mask, right_mask))
```

> Note: The pixelwise check here is conservative (mask shape equality). In WO-04 we’ll compare actual pixel values within aligned bboxes under candidate (pose, Δ). For WO-03 receipts, verifying identical mask shape is sufficient to assert stable matching correctness.

---

## Harness (scripts/run_wo.py)

Add a **WO-03** branch:

1. Load each task id from `--subset`. For each **training pair** `(X_i, Y_i)`:

   * Present them already via WO-01 (or just use raw for now; Π doesn’t change connectivity).
   * Compute components for `X_i` and `Y_i`: `comps_X, rcX`, `comps_Y, rcY`.
   * Call `stable_match(comps_X, comps_Y)` → `pairs, matchRc`.
   * Optionally call `verify_pixelwise_equal` for each pair (mask equality suffices here).
   * Emit receipts JSONL per training pair with:

     * `components.X = rcX`, `components.Y = rcY`
     * `match = matchRc`
     * Assert `rcX.connectivity == rcY.connectivity == "4"` (D2).
2. Double-run the WO and require **identical receipts**.

**Acceptance scenario for 652646ff**: run `X_i` vs `Y_i`; verify matching order stable across runs (especially where several identical 6×6 slice motifs exist).

---

## Acceptance (real ARC) & Red-team

**Acceptance (ids.txt with 652646ff included):**

* `components.connectivity == "4"` always.
* `per_color_counts` correct (deterministic).
* Invariants list sorted deterministically (compare two runs).
* `stable_match` pairs identical across runs.

**Red-team:**

* **Recolor duplicates** in a local copy of a grid (same shapes, different color) → `outline_hash` identical, matching order unchanged.
* **Rotate/flip** a grid in isolation, then Π-present and re-extract → `outline_hash` unchanged due to D4-min; anchors differ, but the lex order + outline hash keeps matching stable.
* **Perturb tie fields**: Create two shapes with identical area/bbox/perim/outline; ensure tie is resolved by anchor_rc, then by color; stable across runs.

---

## Pre-flight (from common mistakes for this WO)

* **D2**: **Use 4-connectivity** only; record `connectivity="4"`; reject 8-connected results.
* Keep outline hashing **color/pose independent** (D4-min on mask only).
* Receipts must include the **full invariant tuple per component** to enable algebraic diffing.

---

## Reviewer checklist (BLOCKER)

* [ ] `components.connectivity == "4"` (freeze).
* [ ] `per_color_counts` make sense; invariants list present and sorted lex.
* [ ] `outline_hash` equal for recolored duplicates and D4 poses of same shape.
* [ ] `stable_match.pairs` identical across double run; `left_only/right_only` consistent.
* [ ] Receipts identical across double run; no volatile fields.
* [ ] Pixelwise verify (mask equality) passes for all matched pairs.

---

## Notes / discussion

* **Where Π fits**: WO-03 operates in Π frame conceptually; since Π doesn’t alter shapes, you can run CC4 on raw or Π-presented grids. For reproducibility, prefer Π grids when available.
* **Why match by invariants instead of pixels?** It’s faster and deterministic, and produces receipts that are easy to compare. WO-04 will use these matches to propose φ candidates and then check pixelwise equality of values under transforms.
* **Why 4-connectivity frozen?** The math spec’s component semantics assume 4-CC; 8-CC changes counts and splits shape families differently → drift.
