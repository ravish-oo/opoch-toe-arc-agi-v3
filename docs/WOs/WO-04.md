A full, receipts-first expansion of **WO-04 — Witness solver (φ,σ) + conjugation + intersection **. It’s wired to WO-01/03, incorporates the common-mistakes items **E2, A1, C2**, and includes a harness path so implementer and reviewer don’t miss anything.

---

# WO-04 — Witness solver (φ,σ) + conjugation + intersection (BLOCKER)

## Objective

For each training pair (in Π frame), **prove** how Y is obtained from X:

* **Geometric law**: piecewise bijection φ (per component) in (D_4 \ltimes \mathbb Z^2) (with optional lattice residues in periodic coframes) such that (Y = X \circ \phi) (values equal on every pixel of each declared domain), with a unique palette role permutation **σ** (Lehmer-encoded) if recoloring is present.
* **Summary law**: φ is **empty** (no pixel transport), and Y’s content is produced by a frozen family rule (e.g., slice/band/argmax). We still produce **σ** (usually id) and **deciding receipts** (candidate sets, per-color counts, decision rule).

Then **conjugate** each training’s ((\phi_i,\sigma_i)) into the test Π frame and **intersect** parameters across trainings. If singleton ⇒ law fixed; if size>1 ⇒ hand to tie-break L in WO-08; if contradiction ⇒ fail-closed and rely on later Meet logic.

**No majority copies. No heuristics.** This WO is a proof generator with receipts.

---

## Files to add/change

```
arc/op/witness.py      # NEW: solve per-pair (φ,σ) + receipts; conjugation; intersection; summary-law receipts
scripts/run_wo.py      # Add WO-04 branch: run witnesses, emit receipts, determinism check
```

Depends on: WO-01 Π (present/unpresent), WO-03 components.

---

## Public contracts (frozen)

```python
# arc/op/witness.py
from __future__ import annotations
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional
import numpy as np

# ===== Encodings (match addendum) =====
@dataclass
class PhiPiece:          # one component’s mapping
    comp_id: int         # index into components list
    pose_id: int         # D4 id (0..7)
    dr: int              # translation in bbox frame (signed)
    dc: int
    r_per: int           # residue basis row period (1 if none)
    c_per: int
    r_res: int           # residue class (0 if none)
    c_res: int

@dataclass
class PhiRc:
    pieces: List[PhiPiece]
    bbox_equal: List[bool]     # per-piece equality checks on declared domain
    domain_pixels: int         # sum of pixels across pieces

@dataclass
class SigmaRc:
    domain_colors: List[int]   # colors touched by the law
    lehmer: List[int]          # permutation encoding (frozen)
    moved_count: int           # recolor_bits

@dataclass
class TrainWitnessRc:
    kind: str                  # "geometric" | "summary"
    phi: Optional[PhiRc]       # None for summary
    sigma: SigmaRc
    # Summary-law receipts (A1/C2 freezes)
    foreground_colors: Optional[List[int]]
    background_colors: Optional[List[int]]
    decision_rule: Optional[str]           # e.g., "strict_majority_foreground_fallback_7"
    per_color_counts: Optional[Dict[int,int]]

@dataclass
class ConjugatedRc:
    phi_star: Optional[PhiRc]  # transported to test Π frame
    sigma: SigmaRc

@dataclass
class IntersectionRc:
    status: str                # "singleton" | "underdetermined" | "contradictory"
    admissible_count: int

# ===== API =====

def solve_witness_for_pair(
    X: np.ndarray, Y: np.ndarray, comps_X, comps_Y
) -> tuple[Optional[List[PhiPiece]], SigmaRc, TrainWitnessRc]:
    """
    Return (φ pieces or None for summary, σ, receipts) for a single training pair (Π frame).
    Must prove pixel equality per declared φ-piece domain (E2), or produce summary receipts (A1/C2).
    """

def conjugate_to_test(
    phi_pieces: Optional[List[PhiPiece]], sigma: SigmaRc,
    Pi_train, Pi_test
) -> tuple[Optional[List[PhiPiece]], ConjugatedRc]:
    """Transport (φ,σ) to the test Π frame (Π*_train → Π*_test)."""

def intersect_witnesses(
    conj_list: List[tuple[Optional[List[PhiPiece]], SigmaRc]]
) -> tuple[Optional[List[PhiPiece]], SigmaRc, IntersectionRc]:
    """
    Intersect parameters across trainings.
    - For geometric: intersect pose_id/Δ/residue per matched component role.
    - For summary: intersection usually yields φ=None (kept) and σ intersection (identity) with summary receipts carried by caller.
    """
```

---

## Algorithm (precise, receipts-first)

### 0) Preliminaries (input)

* Use WO-03 **components** for X and Y to get a stable list/order of components (Π frame).
* For each **matched** component pair (by invariants), attempt a **geometric** witness; otherwise we’ll consider **summary**.

### 1) Geometric φ per component (E2 freeze)

For a matched pair ((C^X, C^Y)):

* Enumerate **pose** ∈ D4 (8), and translations ((\Delta r,\Delta c)) that place (C^X) mask over (C^Y) bbox. If (C^X) or its bbox area is periodic, compute residue basis ((r_{per}, c_{per})) (from WO-05 periods), and allow ((\Delta r,\Delta c)) modulo that lattice.
* For each candidate, **verify pixel equality** on the declared domain:

  * Compare (X\circ (\text{pose},\Delta)) vs (Y) on the component’s bbox **value-wise**.
  * If **exact** for all pixels, accept that **piece** (record `PhiPiece` + `bbox_equal=True`).
* If **no** candidate yields exact equality, geometric witness fails for this component.

If **all** matched components have accepted pieces and their domains are **disjoint** (they are by construction), φ is **the set of pieces**; otherwise geometric fails.

> **Receipts**: `PhiRc.pieces`, `bbox_equal` (all True), and `domain_pixels` sum.

### 2) σ (palette role permutation)

Given φ (geometric) or summary, derive σ as the **unique** permutation that makes all pixels in the law’s **domain** map consistently:

* Build the set of colors touched by the law’s domain (geometric: pixels in φ domains; summary: pixels the rule will write).
* Compute σ as a permutation that maps source colors to target colors so equality holds on those pixels. If multiple σ satisfy equality, **choose lex-smallest Lehmer** (frozen), but in practice with exact equality σ is unique or identity.
* **Receipts**: `domain_colors`, `lehmer`, `moved_count` (= # moved colors).

### 3) Summary law path (A1, C2 freezes)

If geometric fails (no per-component exact φ), we produce a **summary witness**:

* **Candidate sets are part of the law** (A1). Unless a family adapter proves otherwise later, use **all non-zero colors** as the foreground set (\mathcal F) and `{0, 1}` (or `{0}` if `1` not present) as background (\mathcal B) for simple majority/argmax summaries.
* **Decision rule must be frozen** (C2). For strict-majority families:

  * Rule string: `"strict_majority_foreground_fallback_7"` (example); if no strict majority in (\mathcal F), write fallback (e.g., `7` or background `0`/`1` depending on family); among ties in (\mathcal F), choose smallest color.
* **Receipts**:

  * `foreground_colors`, `background_colors`,
  * `per_color_counts` for the decision window/block,
  * `decision_rule` (canonical string).
* In summary mode, **φ=None** and **σ=id** unless the examples force a recolor role (rare).

> Family-specific adapters in WO-10 will replace the generic defaults with proper family rules; what matters here is we **don’t mint** candidates or silently drop colors, and the reviewer can see **exactly** how we decided.

### 4) Conjugation to the test Π frame

For each training i, transport ((\phi_i,\sigma_i)) via:
[
(\phi_i^*, \sigma_i) = \Pi_* \circ \Pi_i^{-1} \circ (\phi_i,\sigma_i) \circ \Pi_i \circ \Pi_*^{-1}
]

* For geometric φ, update pose/Δ in the test frame; residues carry through.
* For summary (φ=None), only σ carries (usually identity), and summary receipts are carried by caller as evidence for law class.
* **Receipts**: `ConjugatedRc` with `phi_star` and `sigma`.

### 5) Intersection across trainings

* **Geometric**: intersect piecewise parameters over matched roles. Every pose_id, Δ, residue must agree; otherwise:

  * If two or more admissible parameter tuples exist ⇒ **underdetermined**.
  * If no consistent tuple ⇒ **contradictory**.
* **Summary**: φ stays None; σ must be compatible across trainings (usually id). If some trainings disagree on class (e.g., different summary family), mark **contradictory** (rare).
* **Receipts**: `IntersectionRc{status, admissible_count}`.

> Underdetermined goes to WO-08 tie-break. Contradictory is fail-closed and will rely on later Meet/unanimity; but WO-04 fails acceptance for that task.

---

## Receipts (first-class everywhere)

Per **training pair**:

* `TrainWitnessRc.kind` = `"geometric"` or `"summary"`.
* If geometric: `PhiRc` (pieces, bbox_equal[], domain_pixels), `SigmaRc`.
* If summary: `SigmaRc`, plus **A1/C2** receipts:
  `foreground_colors`, `background_colors`, `per_color_counts`, `decision_rule`.

Per **conjugation**:

* `ConjugatedRc` with transported φ*, σ.

Per **intersection**:

* `IntersectionRc` (`singleton` | `underdetermined` | `contradictory`, count).

No volatile fields.

> **Note on S(p) mask:** the **singleton free-copy mask** is produced in WO-06. Here we only guarantee **φ exactness** (E2). Reviewer will see S(p) receipts later.

---

## Implementer sketch (core functions)

```python
# arc/op/witness.py (sketch)
from __future__ import annotations
import numpy as np
from dataclasses import dataclass
from typing import List, Dict, Tuple, Optional

# ... (dataclasses from the API block)

def _equality_on_bbox(X: np.ndarray, Y: np.ndarray, r0:int, r1:int, c0:int, c1:int) -> bool:
    return bool(np.array_equal(X[r0:r1, c0:c1], Y[r0:r1, c0:c1]))

def _enumerate_pose_delta(Bx: np.ndarray, By: np.ndarray) -> List[tuple[int,int,int]]:
    """
    Given bbox masks Bx (from X) and By (from Y), return finite list of (pose_id, dr, dc)
    that align Bx onto By's frame. Residues: for now assume none (r_per=c_per=1).
    """
    # Simple version: try every pose and the single translation that aligns top-left anchors.
    # (For periodic residues, we’ll expand in a helper once WO-05 provides periods.)
    poses = []
    # Align top-left to top-left
    for pid in range(8):
        poses.append((pid, 0, 0))
    return poses

def solve_witness_for_pair(X, Y, comps_X, comps_Y):
    # comps_*.invariants: ordered CompInv from WO-03; assume same length & matched by caller
    pieces: List[PhiPiece] = []
    bbox_ok: List[bool] = []
    geometric_ok = True
    # Try per-component geometric equality
    for i, (invX, invY) in enumerate(zip(comps_X.invariants, comps_Y.invariants)):
        # Crop bboxes
        xB = (X[invX.anchor_r:invX.anchor_r+invX.bbox_h, invX.anchor_c:invX.anchor_c+invX.bbox_w] == invX.color)
        yB = (Y[invY.anchor_r:invY.anchor_r+invY.bbox_h, invY.anchor_c:invY.anchor_c+invY.bbox_w] == invY.color)
        ok_here = False
        for pose_id, dr, dc in _enumerate_pose_delta(xB, yB):
            # For this WO: insist on same bbox size to compare; periodic residues later
            if xB.shape != yB.shape: continue
            # Value equality on bbox (proof)
            if np.array_equal(xB, yB):
                pieces.append(PhiPiece(i, pose_id, dr, dc, 1,1,0,0))
                bbox_ok.append(True)
                ok_here = True
                break
        if not ok_here:
            geometric_ok = False
            break
    if geometric_ok and pieces:
        # σ on domain: typically identity; record domain colors and lehmer []
        domain_colors = sorted({inv.color for inv in comps_X.invariants})
        sigma = SigmaRc(domain_colors=domain_colors, lehmer=[], moved_count=0)
        phi_rc = PhiRc(pieces=pieces, bbox_equal=bbox_ok, domain_pixels=int(sum(inv.area for inv in comps_X.invariants)))
        tw_rc = TrainWitnessRc(kind="geometric", phi=phi_rc, sigma=sigma,
                               foreground_colors=None, background_colors=None,
                               decision_rule=None, per_color_counts=None)
        return pieces, sigma, tw_rc

    # Summary path (A1/C2 receipts): generic strict-majority example
    # Foreground = all non-zero in X∪Y; Background = {0,1}∩colors_present
    colors = sorted(set(np.unique(X).tolist()) | set(np.unique(Y).tolist()))
    fg = [c for c in colors if c not in (0,)]
    bg = [c for c in colors if c in (0,1)]
    # For WO-04 we only RECORD counts & rule; actual write happens later (WO-10/Meet)
    # Count per color over Y (or per decision window the family defines; for now, whole grid)
    counts = {c:int(np.sum(Y==c)) for c in colors}
    # Decision rule string frozen:
    rule = "strict_majority_foreground_fallback_0"
    sigma = SigmaRc(domain_colors=sorted(colors), lehmer=[], moved_count=0)
    tw_rc = TrainWitnessRc(kind="summary", phi=None, sigma=sigma,
                           foreground_colors=fg, background_colors=bg,
                           decision_rule=rule, per_color_counts=counts)
    return None, sigma, tw_rc

def conjugate_to_test(phi_pieces, sigma, Pi_train, Pi_test):
    # For now, we forward φ pieces as-is; Pi transforms are applied in runner where frames exist.
    # Receipts still carry the structure; implementer wires actual Π transforms when available.
    return phi_pieces, ConjugatedRc(phi_star=PhiRc(phi_pieces, [True]*len(phi_pieces), 0) if phi_pieces else None,
                                    sigma=sigma)

def intersect_witnesses(conj_list):
    # conj_list: [(phi_pieces or None, sigmaRc), ...]
    # Simple rule for now:
    # - If any None and any non-None → contradictory (mixed law types)
    # - If all None → singleton (summary); σ must match (domain colors same)
    # - If all have pieces → require identical encodings; else underdetermined/contradictory
    kinds = ["none" if p is None else "geom" for p,_ in conj_list]
    if "geom" in kinds and "none" in kinds:
        return None, conj_list[0][1], IntersectionRc("contradictory", 0)
    if all(k=="none" for k in kinds):
        # σ equality check
        s0 = conj_list[0][1].lehmer
        if any(c[1].lehmer != s0 for c in conj_list):
            return None, conj_list[0][1], IntersectionRc("contradictory", 0)
        return None, conj_list[0][1], IntersectionRc("singleton", 1)
    # all geometric
    enc0 = [(p.pose_id, p.dr, p.dc, p.r_per, p.c_per, p.r_res, p.c_res) for p in conj_list[0][0]]
    for p,_ in conj_list[1:]:
        enc = [(q.pose_id, q.dr, q.dc, q.r_per, q.c_per, q.r_res, q.c_res) for q in p]
        if enc != enc0:
            return conj_list[0][0], conj_list[0][1], IntersectionRc("underdetermined", 2)
    return conj_list[0][0], conj_list[0][1], IntersectionRc("singleton", 1)
```

> The sketch shows structure and receipts. Implementer must wire actual Π transforms for proper **conjugation** (using WO-01 metadata) and extend `_enumerate_pose_delta` with lattice residues when WO-05 exposes periods.

---

## Harness (scripts/run_wo.py)

Add a **WO-04** branch:

1. For each task id in `--subset`:

   * Load training pairs; **present** them with WO-01 (Π); compute **components** with WO-03.
   * Call `solve_witness_for_pair(X~, Y~, comps_X, comps_Y)` per training ⇒ per-train receipts.
   * Conjugate to test Π frame: `conjugate_to_test(...)`.
2. **Intersection** across trainings: `intersect_witnesses(conj_list)` ⇒ law status.
3. Emit receipts JSONL per task:

   * `witness.train[i] = TrainWitnessRc`
   * `witness.conjugated[i] = ConjugatedRc`
   * `witness.intersection = IntersectionRc`
4. **Determinism**: run twice, receipts must be identical (no timestamps).

**Acceptance**

* **Geometric**: on 652646ff-style pairs (or simpler rotate/flip), expect **φ pieces present**, `bbox_equal=True` for all, σ identity, and **intersection `singleton`**.
* **Summary**: on oracle 3cd86f4f, expect **φ=None** with **A1/C2 receipts** filled, σ identity, and intersection `singleton`.

**Red-team**

* Make an underdetermined microcase (two admissible φ encodings): verify `IntersectionRc.status=="underdetermined"`; later WO-08 must resolve by L.
* Mix a geometric pair with a summary pair for the same task ⇒ `contradictory`.

---

## Pre-flight (from common mistakes for this WO)

* **E2** Moving content without φ proof is illegal.

  * Every φ piece must pass **per-component bbox equality** (values); receipts show `bbox_equal=True`.
  * φ is **partial**; never union/majority to fill gaps.

* **A1** Dropping a color is illegal.

  * Summary receipts **must** record `foreground_colors`, `background_colors`, and **per-color counts** for the decision window. Do **not** silently exclude 7 or 1.

* **C2** Mode vs strict-majority must be frozen.

  * Must log `decision_rule` string (e.g., `"strict_majority_foreground_fallback_0"`); reviewer checks the math against counts.

---

## Reviewer checklist (BLOCKER)

* [ ] For geometric trainings: `TrainWitnessRc.kind=="geometric"`, `phi.pieces` present, all `bbox_equal==True`, `sigma.moved_count` consistent; **no majority** anywhere.
* [ ] For summary trainings: `kind=="summary"`, `foreground_colors`, `background_colors`, `per_color_counts`, and `decision_rule` present; **A1/C2** satisfied.
* [ ] Conjugation: `ConjugatedRc` present; (φ*,σ) structures consistent.
* [ ] Intersection: `IntersectionRc.status ∈ {"singleton","underdetermined","contradictory"}` with `admissible_count` correct.
* [ ] Receipts identical across double run; no volatile fields.

---

## Notes / discussion

* **Why carry A1/C2 in WO-04 (not only in WO-10)?** Because **this is where we prove the law**. Family adapters will refine summary classes and write outputs later; but if we don’t receipt candidate sets and counts **now**, reviewers can’t debug algebraically.
* **Where does S(p) appear?** The singleton free-copy mask is computed in **WO-06** from φ_i^* intersections; here we only **prove φ** (E2).
* **Conjugation detail:** When you wire Π transforms, remember: ( \Pi_* \circ \Pi_i^{-1} ) wraps both pose and anchor shifts; store that in ConjugatedRc.
